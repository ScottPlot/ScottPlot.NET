{
  "version": "4.1.37",
  "generated": "2022-03-30T02:42:22.3043542Z",
  "recipes": [
    {
      "id": "Axis_label",
      "category": "Axis and Ticks",
      "title": "Axis Customizations",
      "description": "Axes can be customized different ways. Axis labels and colors are the most common types of customizations.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// plot sample data\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\n// These shortcuts are the easiest way to set axis labels\nplt.XLabel(\u0022Horizontal Axis\u0022);\nplt.YLabel(\u0022Vertical Axis\u0022);\nplt.Title(\u0022Axis Customization\u0022);\n\n// Axes labels can be further customized for any axis\nplt.YAxis.Label(\u0022Vertical Axis\u0022, Color.Magenta, size: 24, fontName: \u0022Comic Sans MS\u0022);\n\n// This method will set the color of axis labels, lines, ticks, and tick labels\nplt.XAxis.Color(Color.Green);\n\nplt.SaveFig(\u0022Axis_label.png\u0022);"
    },
    {
      "id": "axis_gridDisableAll",
      "category": "Axis and Ticks",
      "title": "Disable Grid",
      "description": "Visibility of primary X and Y grids can be set using a single method.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// plot sample data\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\n// hide grids\nplt.Grid(false);\n\nplt.SaveFig(\u0022axis_gridDisableAll.png\u0022);"
    },
    {
      "id": "axis_gridDisableOne",
      "category": "Axis and Ticks",
      "title": "Disable Vertical Grid",
      "description": "Grid line visibility can be controlled for each axis individually. Use this to selectively enable grid lines only for the axes of interest. Keep in mind that vertical grid lines are controlled by horizontal axes.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// plot sample data\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\n// each axis has its own visibility controls\nplt.XAxis.Grid(false);\n\nplt.SaveFig(\u0022axis_gridDisableOne.png\u0022);"
    },
    {
      "id": "asis_gridConfigure",
      "category": "Axis and Ticks",
      "title": "Grid Style",
      "description": "Common grid line configurations are available.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// plot sample data\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\n// these helper methods set grid \nplt.Grid(color: Color.FromArgb(50, Color.Green));\nplt.Grid(lineStyle: LineStyle.Dot);\n\nplt.SaveFig(\u0022asis_gridConfigure.png\u0022);"
    },
    {
      "id": "asis_frameless",
      "category": "Axis and Ticks",
      "title": "Frameless Plots",
      "description": "Frameless plots can display data that appraoches the edge of the figure.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\nplt.AxisAuto(0, 0); // zero margin between data and edge of plot\nplt.Frameless();\n\nplt.SaveFig(\u0022asis_frameless.png\u0022);"
    },
    {
      "id": "one_axisonly",
      "category": "Axis and Ticks",
      "title": "One Axis Only",
      "description": "Axis ticks and lines can be disabled. Note that hiding them in this way preserves their whitespace. Setting XAxis.IsVisible to false would collapse the axis entirely. ",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// plot sample data\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\n// hide just the horizontal axis ticks\nplt.XAxis.Ticks(false);\n\n// hide the lines on the bottom, right, and top of the plot\nplt.XAxis.Line(false);\nplt.YAxis2.Line(false);\nplt.XAxis2.Line(false);\n\nplt.SaveFig(\u0022one_axisonly.png\u0022);"
    },
    {
      "id": "ticks_rotated",
      "category": "Axis and Ticks",
      "title": "Rotated X Ticks",
      "description": "Horizontal tick labels can be rotated as desired.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// plot sample data\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\nplt.XAxis.Label(\u0022Horizontal Axis\u0022);\nplt.YAxis.Label(\u0022Vertical Axis\u0022);\n\n// rotate horizontal axis tick labels\nplt.XAxis.TickLabelStyle(rotation: 45);\n\nplt.SaveFig(\u0022ticks_rotated.png\u0022);"
    },
    {
      "id": "ticks_rotatedY",
      "category": "Axis and Ticks",
      "title": "Rotated Y Ticks",
      "description": "Vertical tick labels can be rotated as desired.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// plot sample data\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\nplt.XAxis.Label(\u0022Horizontal Axis\u0022);\nplt.YAxis.Label(\u0022Vertical Axis\u0022);\n\n// rotate horizontal axis tick labels\nplt.YAxis.TickLabelStyle(rotation: 45);\n\nplt.SaveFig(\u0022ticks_rotatedY.png\u0022);"
    },
    {
      "id": "ticks_dateTime",
      "category": "Axis and Ticks",
      "title": "Plotting DateTime Data",
      "description": "This example shows how to display DateTime data on the horizontal axis. Use DateTime.ToOADate() to convert DateTime[] to double[], plot the data,  then tell the axis to format tick labels as dates.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// create data sample data\nDateTime[] myDates = new DateTime[100];\nfor (int i = 0; i \u003C myDates.Length; i\u002B\u002B)\n    myDates[i] = new DateTime(1985, 9, 24).AddDays(7 * i);\n\n// Convert DateTime[] to double[] before plotting\ndouble[] xs = myDates.Select(x =\u003E x.ToOADate()).ToArray();\ndouble[] ys = DataGen.RandomWalk(myDates.Length);\nplt.AddScatter(xs, ys);\n\n// Then tell the axis to display tick labels using a time format\nplt.XAxis.DateTimeFormat(true);\n\nplt.SaveFig(\u0022ticks_dateTime.png\u0022);"
    },
    {
      "id": "asis_gridAdvanced",
      "category": "Advanced Axis Features",
      "title": "Advanced Grid Customization",
      "description": "Grid lines can be extensively customized using various configuration methods.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// plot sample data\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\n// advanced grid customizations are available by accessing Axes directly\nplt.XAxis.MajorGrid(color: Color.FromArgb(100, Color.Black));\nplt.XAxis.MinorGrid(enable: true, color: Color.FromArgb(20, Color.Black));\nplt.YAxis.MajorGrid(lineWidth: 2, lineStyle: LineStyle.Dash, color: Color.Magenta);\n\nplt.SaveFig(\u0022asis_gridAdvanced.png\u0022);"
    },
    {
      "id": "ticks_numericFormatString",
      "category": "Advanced Axis Features",
      "title": "Numeric Format String",
      "description": "Tick labels can be converted to text using a custom format string.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// plot sample data\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\n// See https://tinyurl.com/y86clj9k to learn about numeric format strings\nplt.XAxis.TickLabelFormat(\u0022E2\u0022, dateTimeFormat: false);\nplt.YAxis.TickLabelFormat(\u0022P1\u0022, dateTimeFormat: false);\n\nplt.SaveFig(\u0022ticks_numericFormatString.png\u0022);"
    },
    {
      "id": "ticks_defined",
      "category": "Advanced Axis Features",
      "title": "Manual Tick Labels",
      "description": "Tick positions and labels can be defined manually.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// plot sample data\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\n// manually define X axis tick positions and labels\ndouble[] xPositions = { 7, 21, 37, 46 };\nstring[] xLabels = { \u0022VII\u0022, \u0022XXI\u0022, \u0022XXXVII\u0022, \u0022XLVI\u0022 };\nplt.XAxis.ManualTickPositions(xPositions, xLabels);\n\n// manually define Y axis tick positions and labels\ndouble[] yPositions = { -1, 0, .5, 1 };\nstring[] yLabels = { \u0022bottom\u0022, \u0022center\u0022, \u0022half\u0022, \u0022top\u0022 };\nplt.YAxis.ManualTickPositions(yPositions, yLabels);\n\nplt.SaveFig(\u0022ticks_defined.png\u0022);"
    },
    {
      "id": "ticks_nonLinearX",
      "category": "Advanced Axis Features",
      "title": "NonLinear Tick Spacing",
      "description": "Plot data on regular cartesian space then manually control axis labels to give the appearance of non-linear spacing between points.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// these are our nonlinear data values we wish to plot\ndouble[] amplitudes = { 23.9, 24.2, 24.3, 24.5, 25.3, 26.3, 27.6, 31.4, 33.7, 36,\n38.4, 42, 43.5, 46.1, 48.8, 51.5, 53.2, 55, 56.9, 58.7, 60.6 };\ndouble[] frequencies = { 50, 63, 80, 100, 125, 160, 200, 250, 315, 400, 500, 630,\n 800, 1000, 1250, 1600, 2000, 2500, 3150, 4000, 5000 };\n\n// ignore the \u0022real\u0022 X values and plot data at consecutive X values (0, 1, 2, 3...)\ndouble[] positions = DataGen.Consecutive(frequencies.Length);\nplt.AddScatter(positions, amplitudes);\n\n// then define tick labels based on \u0022real\u0022 X values, rotate them, and give them extra space\nstring[] labels = frequencies.Select(x =\u003E x.ToString()).ToArray();\nplt.XAxis.ManualTickPositions(positions, labels);\nplt.XAxis.TickLabelStyle(rotation: 45);\nplt.XAxis.SetSizeLimit(min: 50); // extra space for rotated ticks\n\n// apply axis labels, trigging a layout reset\nplt.Title(\u0022Vibrational Coupling\u0022);\nplt.YLabel(\u0022Amplitude (dB)\u0022);\nplt.XLabel(\u0022Frequency (Hz)\u0022);\n\nplt.SaveFig(\u0022ticks_nonLinearX.png\u0022);"
    },
    {
      "id": "ticks_descending",
      "category": "Advanced Axis Features",
      "title": "Descending Ticks",
      "description": "ScottPlot will always display data where X values ascend from left to right. To simulate an inverted axis (where numbers decrease from left to right) plot data in the negative space, then invert the sign of tick labels.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// plot the positive data in the negative space\ndouble[] values = DataGen.Sin(50);\nvar sig = plt.AddSignal(values);\nsig.OffsetX = -50;\n\n// then invert the sign of the axis tick labels\nplt.XAxis.TickLabelNotation(invertSign: true);\nplt.YAxis.TickLabelNotation(invertSign: true);\n\nplt.SaveFig(\u0022ticks_descending.png\u0022);"
    },
    {
      "id": "ticks_definedSpacing",
      "category": "Advanced Axis Features",
      "title": "Defined Tick Spacing",
      "description": "The space between tick marks can be manually defined by setting the grid spacing.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// plot the positive data in the negative space\ndouble[] values = DataGen.Sin(50);\nvar sig = plt.AddSignal(values);\nsig.OffsetX = -50;\n\n// then invert the sign of the axis tick labels\nplt.XAxis.ManualTickSpacing(2);\nplt.YAxis.ManualTickSpacing(.1);\n\nplt.SaveFig(\u0022ticks_definedSpacing.png\u0022);"
    },
    {
      "id": "ticks_culture",
      "category": "Advanced Axis Features",
      "title": "Tick Label Culture",
      "description": "Large numbers and dates are formatted differently for different cultures. Hungarian uses spaces to separate large numbers and periods to separate fields in dates.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// generate some data\ndouble[] price = DataGen.RandomWalk(null, 60 * 8, 10000);\nDateTime start = new DateTime(2019, 08, 25, 8, 30, 00);\ndouble pointsPerDay = 24 * 60;\n\n// create the plot\nvar sig = plt.AddSignal(price, pointsPerDay);\nsig.OffsetX = start.ToOADate();\n\n// set the localization\nvar culture = System.Globalization.CultureInfo.CreateSpecificCulture(\u0022hu\u0022); // Hungarian\nplt.SetCulture(culture);\n\n// further decorate the plot\nplt.XAxis.DateTimeFormat(true);\nplt.YAxis.Label(\u0022Price\u0022);\nplt.XAxis.Label(\u0022Date and Time\u0022);\nplt.XAxis2.Label(\u0022Hungarian Formatted DateTime Tick Labels\u0022);\n\nplt.SaveFig(\u0022ticks_culture.png\u0022);"
    },
    {
      "id": "ticks_cultureCustom",
      "category": "Advanced Axis Features",
      "title": "Custom Tick Label Culture",
      "description": "SetCulture() as arguments to let the user manually define formatting strings which will be used globally to change how numbers and dates are formatted.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// generate 10 days of data\nint pointCount = 10;\ndouble[] values = DataGen.RandomWalk(null, pointCount);\ndouble[] days = new double[pointCount];\nDateTime day1 = new DateTime(1985, 09, 24);\nfor (int i = 0; i \u003C days.Length; i\u002B\u002B)\n    days[i] = day1.AddDays(1).AddDays(i).ToOADate();\n\n// plot the data with custom tick format (https://tinyurl.com/ycwh45af)\nplt.AddScatter(days, values);\nplt.XAxis.TickLabelFormat(\u0022M\\\\/dd\u0022, dateTimeFormat: true);\n\nplt.SaveFig(\u0022ticks_cultureCustom.png\u0022);"
    },
    {
      "id": "ticks_multiplier",
      "category": "Advanced Axis Features",
      "title": "Multiplier Notation",
      "description": "Multiplier notation keeps tick labels small when plotting large data values. This style is also called engineering notation or scientific notation.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.AddLine(-1e5, -1e10, 1e5, 1e10);\n\nplt.XAxis.TickLabelNotation(multiplier: true);\nplt.YAxis.TickLabelNotation(multiplier: true);\n\nplt.SaveFig(\u0022ticks_multiplier.png\u0022);"
    },
    {
      "id": "ticks_offset",
      "category": "Advanced Axis Features",
      "title": "Offset Notation",
      "description": "Offset notation keeps tick labels small when plotting large data values that are close together.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.AddLine(1e5 \u002B 111, 1e10 \u002B 111, 1e5 \u002B 222, 1e10 \u002B 222);\n\nplt.XAxis.TickLabelNotation(offset: true);\nplt.YAxis.TickLabelNotation(offset: true);\n\nplt.SaveFig(\u0022ticks_offset.png\u0022);"
    },
    {
      "id": "ticks_definedDateTimeSpace",
      "category": "Advanced Axis Features",
      "title": "Defined DateTime Spacing",
      "description": "This example shows how to use a fixed inter-tick distance for a DateTime axis",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// create a series of dates\nint pointCount = 20;\ndouble[] dates = new double[pointCount];\nvar firstDay = new DateTime(2020, 1, 22);\nfor (int i = 0; i \u003C pointCount; i\u002B\u002B)\n    dates[i] = firstDay.AddDays(i).ToOADate();\n\n// simulate data for each date\ndouble[] values = new double[pointCount];\nRandom rand = new Random(0);\nfor (int i = 1; i \u003C pointCount; i\u002B\u002B)\n    values[i] = values[i - 1] \u002B rand.NextDouble();\n\nplt.AddScatter(dates, values);\nplt.XAxis.DateTimeFormat(true);\n\n// define tick spacing as 1 day (every day will be shown)\nplt.XAxis.ManualTickSpacing(1, ScottPlot.Ticks.DateTimeUnit.Day);\nplt.XAxis.TickLabelStyle(rotation: 45);\n\n// add some extra space for rotated ticks\nplt.XAxis.SetSizeLimit(min: 50);\n\nplt.SaveFig(\u0022ticks_definedDateTimeSpace.png\u0022);"
    },
    {
      "id": "asis_log",
      "category": "Advanced Axis Features",
      "title": "Log Scale",
      "description": "ScottPlot is designed to display 2D data on linear X and Y axes, but you can log-transform data before plotting it and customize the ticks and grid to give the appearance of logarithmic scales.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// These are the dat we will plot with a linear X scale but log Y scale\ndouble[] xs = { 1, 2, 3, 4, 5 };\ndouble[] ys = { 10, 2_000, 50_000, 1_000_000, 1_500_000 };\n\n// Plot the Log10 of all the Y values\ndouble[] logYs = ys.Select(y =\u003E Math.Log10(y)).ToArray();\nvar scatter = plt.AddScatter(xs, logYs, lineWidth: 2, markerSize: 10);\n\n// Use a custom formatter to control the label for each tick mark\nstatic string logTickLabels(double y) =\u003E Math.Pow(10, y).ToString(\u0022N0\u0022);\nplt.YAxis.TickLabelFormat(logTickLabels);\n\n// Use log-spaced minor tick marks and grid lines to make it more convincing\nplt.YAxis.MinorLogScale(true);\nplt.YAxis.MajorGrid(true, Color.FromArgb(80, Color.Black));\nplt.YAxis.MinorGrid(true, Color.FromArgb(20, Color.Black));\nplt.XAxis.MajorGrid(true, Color.FromArgb(80, Color.Black));\n\n// Set the axis limits manually to ensure edges terminate at desirable locations\nplt.SetAxisLimits(0, 6, 0, Math.Log10(10_000_000));\n\nplt.SaveFig(\u0022asis_log.png\u0022);"
    },
    {
      "id": "asis_logTickDensity",
      "category": "Advanced Axis Features",
      "title": "Log Scale Tick Density",
      "description": "Numer of minor ticks between major ticks can be customized.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] ys = ScottPlot.DataGen.Range(100, 10_000, 100, true);\ndouble[] xs = ScottPlot.DataGen.Consecutive(ys.Length);\ndouble[] logYs = ys.Select(y =\u003E Math.Log10(y)).ToArray();\n\nvar scatter = plt.AddScatter(xs, logYs);\n\nstatic string logTickLabels(double y) =\u003E Math.Pow(10, y).ToString(\u0022N0\u0022);\nplt.YAxis.TickLabelFormat(logTickLabels);\n\n// set the number of minor ticks per major tick here\nplt.YAxis.MinorLogScale(true, minorTickCount: 20);\n\n// darken grid line colors\nplt.YAxis.MinorGrid(true);\nplt.YAxis.MinorGrid(true, Color.FromArgb(20, Color.Black));\nplt.YAxis.MajorGrid(true, Color.FromArgb(80, Color.Black));\nplt.XAxis.MajorGrid(true, Color.FromArgb(80, Color.Black));\n\nplt.SaveFig(\u0022asis_logTickDensity.png\u0022);"
    },
    {
      "id": "asis_ruler",
      "category": "Advanced Axis Features",
      "title": "Ruler mode",
      "description": "Ruler mode is an alternative way to display axis ticks. It draws long ticks and offsets the tick labels to give the appearance of a ruler.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\nplt.XAxis.RulerMode(true);\nplt.YAxis.RulerMode(true);\n\nplt.SaveFig(\u0022asis_ruler.png\u0022);"
    },
    {
      "id": "asis_polar",
      "category": "Advanced Axis Features",
      "title": "Polar Coordinates",
      "description": "A helper function converts radius and theta arrays into Cartesian coordinates suitable for plotting with traditioanl plot types.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// create data with polar coordinates\nint count = 400;\ndouble step = 0.01;\n\ndouble[] rs = new double[count];\ndouble[] thetas = new double[count];\n\nfor (int i = 0; i \u003C rs.Length; i\u002B\u002B)\n{\n    rs[i] = 1 \u002B i * step;\n    thetas[i] = i * 2 * Math.PI * step;\n}\n\n// convert polar data to Cartesian data\n(double[] xs, double[] ys) = ScottPlot.Tools.ConvertPolarCoordinates(rs, thetas);\n\n// plot the Cartesian data\nplt.AddScatter(xs, ys);\n\n// decorate the plot\nplt.Title(\u0022Scatter Plot of Polar Data\u0022);\nplt.AxisScaleLock(true);\n\nplt.SaveFig(\u0022asis_polar.png\u0022);"
    },
    {
      "id": "asis_image",
      "category": "Advanced Axis Features",
      "title": "Images as Axis Labels",
      "description": "Images can be used as axis labels to allow for things like LaTeX axis labels.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// create an interesting plot\ndouble[] xs = DataGen.Range(-5, 5, .5);\ndouble[] ys = DataGen.Range(-5, 5, .5);\nVector2[,] vectors = new Vector2[xs.Length, ys.Length];\nfor (int i = 0; i \u003C xs.Length; i\u002B\u002B)\n    for (int j = 0; j \u003C ys.Length; j\u002B\u002B)\n        vectors[i, j] = new Vector2(ys[j], -15 * Math.Sin(xs[i]));\nplt.AddVectorField(vectors, xs, ys, colormap: Drawing.Colormap.Turbo);\n\n// use images as axis labels\nplt.XAxis.ImageLabel(new Bitmap(\u0022Images/theta.png\u0022));\nplt.YAxis.ImageLabel(new Bitmap(\u0022Images/d_theta_dt.png\u0022));\n\nplt.SaveFig(\u0022asis_image.png\u0022);"
    },
    {
      "id": "asis_imageTransparent",
      "category": "Advanced Axis Features",
      "title": "Transparent Images Axis Labels",
      "description": "Transparency in PNGs is respected, but JPEG files do not support transparency.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.Style(Style.Light2);\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\n// vertical axis label uses a transparent PNG\nplt.YAxis.ImageLabel(new Bitmap(\u0022Images/d_theta_dt.png\u0022));\n\n// horizontal axis label uses a non-transparent JPEG\nplt.XAxis.ImageLabel(new Bitmap(\u0022Images/theta.jpg\u0022));\n\nplt.SaveFig(\u0022asis_imageTransparent.png\u0022);"
    },
    {
      "id": "asis_tickDensity",
      "category": "Advanced Axis Features",
      "title": "Tick Density",
      "description": "Axis tick density can be adjusted by the user. The largest the density is, the more ticks are displayed. Setting this value too high will result in overlapping tick labels.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\nplt.XAxis.Label(\u0022Lower Density Ticks\u0022);\nplt.XAxis.TickDensity(0.2);\n\nplt.YAxis.Label(\u0022Higher Density Ticks\u0022);\nplt.YAxis.TickDensity(3);\n\nplt.SaveFig(\u0022asis_tickDensity.png\u0022);"
    },
    {
      "id": "asis_minimumTickSpacing",
      "category": "Advanced Axis Features",
      "title": "Minimum Tick Spacing",
      "description": "Minimum tick spacing can be defined such that zooming in does not produce more grid lines, ticks, and tick labels beyond the defined limit.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\nplt.YAxis.MinimumTickSpacing(1);\nplt.XAxis.MinimumTickSpacing(25);\n\nplt.SaveFig(\u0022asis_minimumTickSpacing.png\u0022);"
    },
    {
      "id": "asis_custom_tick_formatter",
      "category": "Advanced Axis Features",
      "title": "Custom Tick Formatter",
      "description": "For ultimate control over tick label format you can create a custom formatter function and use that to convert positions to labels. This allows logic to be used to format tick labels.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.AddSignal(ScottPlot.DataGen.Sin(51));\nplt.AddSignal(ScottPlot.DataGen.Cos(51));\n\n// create a custom formatter as a static class\nstatic string customTickFormatter(double position)\n{\n    if (position == 0)\n        return \u0022zero\u0022;\n    else if (position \u003E 0)\n        return $\u0022\u002B{position:F2}\u0022;\n    else\n        return $\u0022({Math.Abs(position):F2})\u0022;\n}\n\n// use the custom formatter for horizontal and vertical tick labels\nplt.XAxis.TickLabelFormat(customTickFormatter);\nplt.YAxis.TickLabelFormat(customTickFormatter);\n\nplt.SaveFig(\u0022asis_custom_tick_formatter.png\u0022);"
    },
    {
      "id": "ticks_invert_tick_mark_direction",
      "category": "Advanced Axis Features",
      "title": "Invert tick mark direction",
      "description": "Tick marks can be outward (default) or inverted to appear as inward lines relative to the edge of the plot area.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\nplt.XAxis.TickMarkDirection(outward: false);\nplt.YAxis.TickMarkDirection(outward: false);\n\nplt.SaveFig(\u0022ticks_invert_tick_mark_direction.png\u0022);"
    },
    {
      "id": "misc_interpolation",
      "category": "Misc",
      "title": "Spline Interpolation",
      "description": "Interpolated splines create curves with many X/Y points to smoothly connect a limited number of input points.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// create a small number of X/Y data points and display them\nRandom rand = new(1234);\ndouble[] xs = DataGen.RandomWalk(rand, 20);\ndouble[] ys = DataGen.RandomWalk(rand, 20);\n\n// interpolate the data to create a smooth curve\n(double[] smoothXs, double[] smoothYs) = ScottPlot.Statistics.Interpolation.Cubic.InterpolateXY(xs, ys, 200);\n\n// plot the original vs interpolated lines\nplt.AddScatter(xs, ys, Color.Green, markerSize: 10, lineWidth: 1, label: \u0022Original\u0022);\nplt.AddScatter(smoothXs, smoothYs, Color.Magenta, label: \u0022Interpolated\u0022);\nplt.Legend();\n\nplt.SaveFig(\u0022misc_interpolation.png\u0022);"
    },
    {
      "id": "misc_interpolation_types",
      "category": "Misc",
      "title": "Spline Interpolation Types",
      "description": "Different methods are available for smoothing data using interpolation, curve fitting, or corner cutting. Notice that some methods produce curves which pass through the original data points and others do not.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.Palette = ScottPlot.Palette.ColorblindFriendly;\n\n// generate random data\nSystem.Random rand = new(12345);\nvar xs = ScottPlot.DataGen.RandomWalk(rand, 20);\nvar ys = ScottPlot.DataGen.RandomWalk(rand, 20);\nplt.AddScatter(xs, ys, lineStyle: ScottPlot.LineStyle.Dash, markerSize: 10, label: \u0022original\u0022);\n\n// interpolate the same data in different ways\n(double[] bzX, double[] bzY) = ScottPlot.Statistics.Interpolation.Bezier.InterpolateXY(xs, ys, .005);\n(double[] crX, double[] crY) = ScottPlot.Statistics.Interpolation.CatmullRom.InterpolateXY(xs, ys, 15);\n(double[] chX, double[] chY) = ScottPlot.Statistics.Interpolation.Chaikin.InterpolateXY(xs, ys, 4);\n(double[] cbX, double[] cbY) = ScottPlot.Statistics.Interpolation.Cubic.InterpolateXY(xs, ys, 200);\n\n// display the different curves as line plots\nplt.AddScatterLines(bzX, bzY, lineWidth: 2, label: $\u0022Bezier\u0022);\nplt.AddScatterLines(crX, crY, lineWidth: 2, label: $\u0022Catmull-Rom\u0022);\nplt.AddScatterLines(chX, chY, lineWidth: 2, label: $\u0022Chaikin\u0022);\nplt.AddScatterLines(cbX, cbY, lineWidth: 2, label: $\u0022Cubic\u0022);\n\n// style the plot\nplt.Legend();\nplt.Frameless();\nplt.Grid(false);\nplt.XAxis2.Label(\u0022Spline Interpolation\u0022, size: 28, bold: true);\n\nplt.SaveFig(\u0022misc_interpolation_types.png\u0022);"
    },
    {
      "id": "misc_ap",
      "category": "Misc",
      "title": "Action Potential",
      "description": "The raw trace (voltage) and first derivative (voltage change / time) of a mammalian action potential.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// obtain a signal for the voltage\ndouble[] ap = DataGen.ActionPotential();\nplt.Title(\u0022Neuronal Action Potential\u0022);\n\n// data is sampled at 20 kHz but we want to display ms units\nint sampleRate = 20;\nplt.XAxis.Label(\u0022Time (milliseconds)\u0022);\n\n// plot the voltage in blue on the primary Y axis\nvar sig1 = plt.AddSignal(ap, sampleRate);\nsig1.YAxisIndex = 0;\nsig1.LineWidth = 3;\nsig1.Color = Color.Blue;\nplt.YAxis.Label(\u0022Membrane Potential (mV)\u0022);\nplt.YAxis.Color(Color.Blue);\n\n// calculate the first derivative\ndouble[] deriv = new double[ap.Length];\nfor (int i = 1; i \u003C deriv.Length; i\u002B\u002B)\n    deriv[i] = (ap[i] - ap[i - 1]) * sampleRate;\nderiv[0] = deriv[1];\n\n// plot the first derivative in red on the secondary Y axis\nvar sig2 = plt.AddSignal(deriv, sampleRate);\nsig2.YAxisIndex = 1;\nsig2.LineWidth = 3;\nsig2.Color = Color.FromArgb(120, Color.Red);\nplt.YAxis2.Label(\u0022Rate of Change (mV/ms)\u0022);\nplt.YAxis2.Color(Color.Red);\nplt.YAxis2.Ticks(true);\n\n// zoom in on the interesting area\nplt.SetAxisLimits(40, 60);\n\nplt.SaveFig(\u0022misc_ap.png\u0022);"
    },
    {
      "id": "misc_dpiScale",
      "category": "Misc",
      "title": "Display Scaling",
      "description": "When display scaling is enabled the dots per inch (DPI) is changed so images appear larger. When scaling is increased bitmap images are stretched to appear larger, but may appear blurry as a result. Alternatively images could be increased in size when DPI scaling is enabled, but fonts and lines may appear small. This example shows how to increase the size of common plot components so they look good on high resolution scaled displays (e.g., 4K monitors). DPI stretching can be set in the user control\u0027s Configuration module.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nvar sig1 = plt.AddSignal(DataGen.Sin(51));\nsig1.Label = \u0022Sin\u0022;\nsig1.MarkerSize = 7;\nsig1.LineWidth = 2;\n\nvar sig2 = plt.AddSignal(DataGen.Cos(51));\nsig2.Label = \u0022Cos\u0022;\nsig2.MarkerSize = 7;\nsig2.LineWidth = 2;\n\nvar legend = plt.Legend();\nlegend.FontSize = 24;\n\nplt.Title(\u0022Plot with Large Features\u0022);\nplt.YLabel(\u0022Vertical Axis\u0022);\nplt.XLabel(\u0022Horizontal Axis\u0022);\n\nplt.YAxis.LabelStyle(fontSize: 24);\nplt.XAxis.LabelStyle(fontSize: 24);\nplt.XAxis2.LabelStyle(fontSize: 36);\n\nplt.YAxis.TickLabelStyle(fontSize: 18);\nplt.XAxis.TickLabelStyle(fontSize: 18);\n\nplt.YAxis.MajorGrid(lineWidth: 2);\nplt.XAxis.MajorGrid(lineWidth: 2);\n\nplt.SaveFig(\u0022misc_dpiScale.png\u0022);"
    },
    {
      "id": "multiAxis_primary",
      "category": "Multi-Axis",
      "title": "Primary Axes",
      "description": "Plots always have 4 fundamental axes available to work with. Primary axes (XAxis and YAxis) are axis index 0. Secondary axes (XAxis2 and YAxis2) are axis index 1.By default primary axes are totally visible, and secondary axes have ticks hidden and no label. Sometimes the top axis (XAxis2) is given a label to simulate a plot title.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// plot one set of data using the primary Y axis\nvar sigSmall = plt.AddSignal(DataGen.Sin(51, mult: 1), sampleRate: 1);\nsigSmall.YAxisIndex = 0;\nsigSmall.XAxisIndex = 0;\nplt.XAxis.Label(\u0022Primary X Axis\u0022);\nplt.YAxis.Label(\u0022Primary Y Axis\u0022);\nplt.XAxis.Color(sigSmall.Color);\nplt.YAxis.Color(sigSmall.Color);\n\n// plot another set of data using the secondary axes\nvar sigBig = plt.AddSignal(DataGen.Cos(51, mult: 100), sampleRate: 100);\nsigBig.YAxisIndex = 1;\nsigBig.XAxisIndex = 1;\nplt.YAxis2.Ticks(true); // ticks weren\u0027t visible by default\nplt.XAxis2.Ticks(true); // ticks weren\u0027t visible by default\nplt.YAxis2.Color(sigBig.Color);\nplt.XAxis2.Color(sigBig.Color);\nplt.YAxis2.Label(\u0022Secondary Y Axis\u0022);\nplt.XAxis2.Label(\u0022Secondary X Axis\u0022);\n\nplt.SaveFig(\u0022multiAxis_primary.png\u0022);"
    },
    {
      "id": "multiAxis_additional",
      "category": "Multi-Axis",
      "title": "Additional Y Axis",
      "description": "Additional axes can be added on any edge. Additional axes stack away from the plot area.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// plot one set of data using the primary Y axis\nvar sigSmall = plt.AddSignal(DataGen.Sin(51, mult: 1));\nsigSmall.YAxisIndex = 0;\nplt.YAxis.Label(\u0022Primary Axis\u0022);\nplt.YAxis.Color(sigSmall.Color);\n\n// plot another set of data using an additional axis\nvar sigBig = plt.AddSignal(DataGen.Cos(51, mult: 100));\nvar yAxis3 = plt.AddAxis(Renderable.Edge.Left, axisIndex: 2);\nsigBig.YAxisIndex = 2;\nyAxis3.Label(\u0022Additional Axis\u0022);\nyAxis3.Color(sigBig.Color);\n\nplt.SaveFig(\u0022multiAxis_additional.png\u0022);"
    },
    {
      "id": "multiAxis_right",
      "category": "Multi-Axis",
      "title": "Right Y Axis",
      "description": "This example demonstrates how to display a Y axis on the right side of the figure. The vertical axis to the right of the figure is index 1, so plots must be updated to indicate they are to use a nonstandard axis index.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] values = DataGen.RandomWalk(100);\nvar sig = plt.AddSignal(values);\nsig.YAxisIndex = 1;\n\nplt.YAxis.Ticks(false);\nplt.YAxis.Grid(false);\nplt.YAxis2.Ticks(true);\nplt.YAxis2.Grid(true);\nplt.YAxis2.Label(\u0022Value\u0022);\nplt.XAxis.Label(\u0022Sample Number\u0022);\n\nplt.SaveFig(\u0022multiAxis_right.png\u0022);"
    },
    {
      "id": "multiAxis_top",
      "category": "Multi-Axis",
      "title": "Top Y Axis",
      "description": "This example demonstrates how to display an X axis above the figure. The horizontal axis above the figure is index 1, so plots must be updated to indicate they are to use a nonstandard axis index.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] values = DataGen.RandomWalk(100);\nvar sig = plt.AddSignal(values);\nsig.XAxisIndex = 1;\n\nplt.XAxis.Ticks(false);\nplt.XAxis.Grid(false);\nplt.XAxis2.Ticks(true);\nplt.XAxis2.Grid(true);\nplt.XAxis2.Label(\u0022Sample Number\u0022);\nplt.YAxis.Label(\u0022Value\u0022);\n\nplt.SaveFig(\u0022multiAxis_top.png\u0022);"
    },
    {
      "id": "multiAxis_invisible",
      "category": "Multi-Axis",
      "title": "Axis Visibility",
      "description": "Visibility of axes can be toggled. In this example an additional Y axis is added but the primary Y axis is hidden. The result is a plot that appears to only have one Y axis.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// plot one set of data using the primary Y axis\nvar sigSmall = plt.AddSignal(DataGen.Sin(51, mult: 1));\nsigSmall.YAxisIndex = 0;\nplt.YAxis.Label(\u0022Primary Axis\u0022);\nplt.YAxis.Color(sigSmall.Color);\n\n// plot another set of data using an additional axis\nvar sigBig = plt.AddSignal(DataGen.Cos(51, mult: 100));\nvar yAxis3 = plt.AddAxis(Renderable.Edge.Left, axisIndex: 2);\nsigBig.YAxisIndex = 2;\nyAxis3.Label(\u0022Additional Axis\u0022);\nyAxis3.Color(sigBig.Color);\n\n// hide the primary Y axis\nplt.YAxis.IsVisible = false;\n\nplt.SaveFig(\u0022multiAxis_invisible.png\u0022);"
    },
    {
      "id": "palette_Category10",
      "category": "Palette",
      "title": "Category10",
      "description": "This 10-color palette is the default colorset used by ScottPlot. It is the same default colorset used by modern versions of Matplotlib (https://matplotlib.org/2.0.2/users/dflt_style_changes.html)",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.Palette = ScottPlot.Palette.Category10;\n\nfor (int i = 0; i \u003C plt.Palette.Count(); i\u002B\u002B)\n{\n    double[] xs = DataGen.Consecutive(100);\n    double[] ys = DataGen.Sin(100, phase: -i * .5 / plt.Palette.Count());\n    plt.AddScatterLines(xs, ys, lineWidth: 3);\n}\n\nplt.Title($\u0022{plt.Palette}\u0022);\nplt.AxisAuto(0, 0.1);\n\nplt.SaveFig(\u0022palette_Category10.png\u0022);"
    },
    {
      "id": "palette_Category20",
      "category": "Palette",
      "title": "Category20",
      "description": "This 20-color palette is similar to the default, but optimized for situations where more than 10 plottables are required. Every second color is a lighter version of the color before it. This palette was sourced from Matplotlib.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.Palette = ScottPlot.Palette.Category20;\n\nfor (int i = 0; i \u003C plt.Palette.Count(); i\u002B\u002B)\n{\n    double[] xs = DataGen.Consecutive(100);\n    double[] ys = DataGen.Sin(100, phase: -i * .5 / plt.Palette.Count());\n    plt.AddScatterLines(xs, ys, lineWidth: 3);\n}\n\nplt.Title($\u0022{plt.Palette}\u0022);\nplt.AxisAuto(0, 0.1);\n\nplt.SaveFig(\u0022palette_Category20.png\u0022);"
    },
    {
      "id": "palette_Aurora",
      "category": "Palette",
      "title": "Aurora",
      "description": "Aurora is a 5-color palette sourced from Nord.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.Palette = ScottPlot.Palette.Aurora;\n\nfor (int i = 0; i \u003C plt.Palette.Count(); i\u002B\u002B)\n{\n    double[] xs = DataGen.Consecutive(100);\n    double[] ys = DataGen.Sin(100, phase: -i * .5 / plt.Palette.Count());\n    plt.AddScatterLines(xs, ys, lineWidth: 3);\n}\n\nplt.Title($\u0022{plt.Palette}\u0022);\nplt.AxisAuto(0, 0.1);\n\nplt.SaveFig(\u0022palette_Aurora.png\u0022);"
    },
    {
      "id": "palette_Frost",
      "category": "Palette",
      "title": "Frost",
      "description": "Frost is a 4-color palette sourced from Nord.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.Palette = ScottPlot.Palette.Frost;\n\nfor (int i = 0; i \u003C plt.Palette.Count(); i\u002B\u002B)\n{\n    double[] xs = DataGen.Consecutive(100);\n    double[] ys = DataGen.Sin(100, phase: -i * .5 / plt.Palette.Count());\n    plt.AddScatterLines(xs, ys, lineWidth: 3);\n}\n\nplt.Title($\u0022{plt.Palette}\u0022);\nplt.AxisAuto(0, 0.1);\n\nplt.SaveFig(\u0022palette_Frost.png\u0022);"
    },
    {
      "id": "palette_Nord",
      "category": "Palette",
      "title": "Nord",
      "description": "Nord is a 7-color palette derived from Aurora source from NordConEmu.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.Palette = ScottPlot.Palette.Nord;\n\nfor (int i = 0; i \u003C plt.Palette.Count(); i\u002B\u002B)\n{\n    double[] xs = DataGen.Consecutive(100);\n    double[] ys = DataGen.Sin(100, phase: -i * .5 / plt.Palette.Count());\n    plt.AddScatterLines(xs, ys, lineWidth: 3);\n}\n\nplt.Title($\u0022{plt.Palette}\u0022);\nplt.AxisAuto(0, 0.1);\n\nplt.SaveFig(\u0022palette_Nord.png\u0022);"
    },
    {
      "id": "palette_PolarNight",
      "category": "Palette",
      "title": "PolarNight",
      "description": "PolarNight is a 4-color palette sourced from Nord. This palette is optimized for a dark background.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.Palette = ScottPlot.Palette.PolarNight;\n\nfor (int i = 0; i \u003C plt.Palette.Count(); i\u002B\u002B)\n{\n    double[] xs = DataGen.Consecutive(100);\n    double[] ys = DataGen.Sin(100, phase: -i * .5 / plt.Palette.Count());\n    plt.AddScatterLines(xs, ys, lineWidth: 3);\n}\n\nplt.Title($\u0022{plt.Palette}\u0022);\nplt.AxisAuto(0, 0.1);\nplt.Style(ScottPlot.Style.Blue2);\n\nplt.SaveFig(\u0022palette_PolarNight.png\u0022);"
    },
    {
      "id": "palette_SnowStorm",
      "category": "Palette",
      "title": "SnowStorm",
      "description": "SnowStorm is a 3-color palette sourced from Nord.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.Palette = ScottPlot.Palette.SnowStorm;\n\nfor (int i = 0; i \u003C plt.Palette.Count(); i\u002B\u002B)\n{\n    double[] xs = DataGen.Consecutive(100);\n    double[] ys = DataGen.Sin(100, phase: -i * .5 / plt.Palette.Count());\n    plt.AddScatterLines(xs, ys, lineWidth: 3);\n}\n\nplt.Title($\u0022{plt.Palette}\u0022);\nplt.AxisAuto(0, 0.1);\n\nplt.SaveFig(\u0022palette_SnowStorm.png\u0022);"
    },
    {
      "id": "palette_OneHalf",
      "category": "Palette",
      "title": "OneHalf",
      "description": "OneHalf is a 7-color palette sourced from Sublime",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.Palette = ScottPlot.Palette.OneHalf;\n\nfor (int i = 0; i \u003C plt.Palette.Count(); i\u002B\u002B)\n{\n    double[] xs = DataGen.Consecutive(100);\n    double[] ys = DataGen.Sin(100, phase: -i * .5 / plt.Palette.Count());\n    plt.AddScatterLines(xs, ys, lineWidth: 3);\n}\n\nplt.Title($\u0022{plt.Palette}\u0022);\nplt.AxisAuto(0, 0.1);\n\nplt.SaveFig(\u0022palette_OneHalf.png\u0022);"
    },
    {
      "id": "palette_OneHalfDark",
      "category": "Palette",
      "title": "OneHalfDark",
      "description": "OneHalfDark is a 7-color palette of colors complimentary to the OneHalf palette desaturated and optimized for a dark background. #2e3440 is a recommended background color with this palette.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.Palette = ScottPlot.Palette.OneHalfDark;\n\nfor (int i = 0; i \u003C plt.Palette.Count(); i\u002B\u002B)\n{\n    double[] xs = DataGen.Consecutive(100);\n    double[] ys = DataGen.Sin(100, phase: -i * .5 / plt.Palette.Count());\n    plt.AddScatterLines(xs, ys, lineWidth: 3);\n}\n\nplt.Title($\u0022{plt.Palette}\u0022);\nplt.AxisAuto(0, 0.1);\nplt.Style(ScottPlot.Style.Gray1);\nvar bnColor = System.Drawing.ColorTranslator.FromHtml(\u0022#2e3440\u0022);\nplt.Style(figureBackground: bnColor, dataBackground: bnColor);\n\nplt.SaveFig(\u0022palette_OneHalfDark.png\u0022);"
    },
    {
      "id": "palette_Custom",
      "category": "Palette",
      "title": "Custom",
      "description": "A custom palette can be created from an array of HTML color values. These colors will be used as the default colors for new plottables added to the plot.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// custom colors generated using \u0022i want hue\u0022 http://medialab.github.io/iwanthue/\nstring[] customColors = { \u0022#019d9f\u0022, \u0022#7d3091\u0022, \u0022#57e075\u0022, \u0022#e5b5fa\u0022, \u0022#009118\u0022 };\n\n// create a custom palette and set it in the plot module\nplt.Palette = ScottPlot.Palette.FromHtmlColors(customColors);\n\nfor (int i = 0; i \u003C plt.Palette.Count(); i\u002B\u002B)\n{\n    double[] xs = DataGen.Consecutive(100);\n    double[] ys = DataGen.Sin(100, phase: -i * .5 / plt.Palette.Count());\n    plt.AddScatterLines(xs, ys, lineWidth: 3);\n}\n\nplt.Title($\u0022{plt.Palette}\u0022);\nplt.AxisAuto(0, 0.1);\n\nplt.SaveFig(\u0022palette_Custom.png\u0022);"
    },
    {
      "id": "palette_Microcharts",
      "category": "Palette",
      "title": "Microcharts",
      "description": "This is the default 12-color palette used by Microcharts.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.Palette = ScottPlot.Palette.Microcharts;\n\nfor (int i = 0; i \u003C plt.Palette.Count(); i\u002B\u002B)\n{\n    double[] xs = DataGen.Consecutive(100);\n    double[] ys = DataGen.Sin(100, phase: -i * .5 / plt.Palette.Count());\n    plt.AddScatterLines(xs, ys, lineWidth: 3);\n}\n\nplt.Title($\u0022{plt.Palette}\u0022);\nplt.AxisAuto(0, 0.1);\n\nplt.SaveFig(\u0022palette_Microcharts.png\u0022);"
    },
    {
      "id": "palette_ColorblindFriendly",
      "category": "Palette",
      "title": "Colorblind Friendly",
      "description": "8-color palette that has good overall variability and can be differentiated by individuals with red-green color blindness. Colors originated from Wong 2011, https://www.nature.com/articles/nmeth.1618.pdf",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.Palette = ScottPlot.Palette.ColorblindFriendly;\n\nfor (int i = 0; i \u003C plt.Palette.Count(); i\u002B\u002B)\n{\n    double[] xs = DataGen.Consecutive(100);\n    double[] ys = DataGen.Sin(100, phase: -i * .5 / plt.Palette.Count());\n    plt.AddScatterLines(xs, ys, lineWidth: 3);\n}\n\nplt.Title($\u0022{plt.Palette}\u0022);\nplt.AxisAuto(0, 0.1);\n\nplt.SaveFig(\u0022palette_ColorblindFriendly.png\u0022);"
    },
    {
      "id": "quickstart_scatter",
      "category": "Quickstart",
      "title": "Scatter Plot",
      "description": "Scatter plots have paired X/Y points.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// sample data\ndouble[] xs = DataGen.Consecutive(51);\ndouble[] sin = DataGen.Sin(51);\ndouble[] cos = DataGen.Cos(51);\n\n// plot the data\nplt.AddScatter(xs, sin);\nplt.AddScatter(xs, cos);\n\n// customize the axis labels\nplt.Title(\u0022ScottPlot Quickstart\u0022);\nplt.XLabel(\u0022Horizontal Axis\u0022);\nplt.YLabel(\u0022Vertical Axis\u0022);\n\nplt.SaveFig(\u0022quickstart_scatter.png\u0022);"
    },
    {
      "id": "quickstart_signal",
      "category": "Quickstart",
      "title": "Signal Plot",
      "description": "Signal plots have evenly spaced Y points. Signal plots are very fast and can interactively display millions of data points. There are many different types of plottable objects, each serving a different purpose.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] values = DataGen.RandomWalk(1_000_000);\nplt.AddSignal(values, sampleRate: 48_000);\nplt.Title(\u0022One Million Points\u0022);\n\nplt.SaveFig(\u0022quickstart_signal.png\u0022);"
    },
    {
      "id": "quickstart_axis",
      "category": "Quickstart",
      "title": "Axis Labels and Limits",
      "description": "Axis labels and limits can be customized",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] time = DataGen.Consecutive(51);\ndouble[] voltage = DataGen.Sin(51);\nplt.AddScatter(time, voltage);\n\n// Axes can be customized\nplt.XAxis.Label(\u0022Time (milliseconds)\u0022);\nplt.YAxis.Label(\u0022Voltage (mV)\u0022);\nplt.XAxis2.Label(\u0022Important Experiment\u0022);\n\n// Set axis limits to control the view\nplt.SetAxisLimits(-20, 80, -2, 2);\n\nplt.SaveFig(\u0022quickstart_axis.png\u0022);"
    },
    {
      "id": "quickstart_add",
      "category": "Quickstart",
      "title": "Manually add a Plottable",
      "description": "You can create a plot manually, then add it to the plot with Add(). This allows you to create custom plot types and add them to the plot.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] xs = DataGen.Consecutive(51);\ndouble[] sin = DataGen.Sin(51);\n\n// instantiate a plottable\nvar splt = new ScottPlot.Plottable.ScatterPlot(xs, sin);\n\n// customize its style or change its data as desired\nsplt.Color = Color.Navy;\nsplt.MarkerSize = 10;\nsplt.MarkerShape = MarkerShape.filledDiamond;\n\n// add it to the plot\nplt.Add(splt);\n\nplt.SaveFig(\u0022quickstart_add.png\u0022);"
    },
    {
      "id": "quickstart_remove",
      "category": "Quickstart",
      "title": "Remove a Plottable",
      "description": "Call Remove() to remove a specific plottable.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] xs = DataGen.Consecutive(51);\ndouble[] sin = DataGen.Sin(51);\ndouble[] cos = DataGen.Sin(51);\n\nvar sinPlot = plt.AddScatter(xs, sin, color: Color.Red);\nvar cosPlot = plt.AddScatter(xs, cos, color: Color.Blue);\n\nplt.Remove(sinPlot);\n\nplt.SaveFig(\u0022quickstart_remove.png\u0022);"
    },
    {
      "id": "quickstart_clear",
      "category": "Quickstart",
      "title": "Clear Plottables",
      "description": "Call Clear() to remove all plottables from the plot. Overloads of Clear() allow you to remote one type of plottable, or a specific plottable.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] xs = DataGen.Consecutive(51);\ndouble[] sin = DataGen.Sin(51);\ndouble[] cos = DataGen.Sin(51);\n\nplt.AddScatter(xs, sin, color: Color.Red);\nplt.Clear();\nplt.AddScatter(xs, cos, color: Color.Blue);\n\nplt.SaveFig(\u0022quickstart_clear.png\u0022);"
    },
    {
      "id": "stats_histogram",
      "category": "Statistics",
      "title": "Histogram",
      "description": "ScottPlot.Statistics.Common contains methods for creating histograms.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// generate sample heights are based on https://ourworldindata.org/human-height\nRandom rand = new(0);\ndouble[] values = ScottPlot.DataGen.RandomNormal(rand, pointCount: 1234, mean: 178.4, stdDev: 7.6);\n\n// create a histogram\n(double[] counts, double[] binEdges) = ScottPlot.Statistics.Common.Histogram(values, min: 140, max: 220, binSize: 1);\ndouble[] leftEdges = binEdges.Take(binEdges.Length - 1).ToArray();\n\n// display the histogram counts as a bar plot\nvar bar = plt.AddBar(values: counts, positions: leftEdges);\nbar.BarWidth = 1;\n\n// customize the plot style\nplt.YAxis.Label(\u0022Count (#)\u0022);\nplt.XAxis.Label(\u0022Height (cm)\u0022);\nplt.SetAxisLimits(yMin: 0);\n\nplt.SaveFig(\u0022stats_histogram.png\u0022);"
    },
    {
      "id": "stats_histogramProbability",
      "category": "Statistics",
      "title": "Histogram Probability",
      "description": "Histograms can be displayed as binned probability instead of binned counts. The ideal probability distribution can also be plotted.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// generate sample heights are based on https://ourworldindata.org/human-height\nRandom rand = new(0);\ndouble[] values = ScottPlot.DataGen.RandomNormal(rand, pointCount: 1234, mean: 178.4, stdDev: 7.6);\n\n// create a histogram\n(double[] probabilities, double[] binEdges) = ScottPlot.Statistics.Common.Histogram(values, min: 140, max: 220, binSize: 1, density: true);\ndouble[] leftEdges = binEdges.Take(binEdges.Length - 1).ToArray();\n\n// display histogram probabability as a bar plot\nvar bar = plt.AddBar(values: probabilities, positions: leftEdges);\nbar.BarWidth = 1;\nbar.FillColor = ColorTranslator.FromHtml(\u0022#9bc3eb\u0022);\nbar.BorderColor = ColorTranslator.FromHtml(\u0022#82add9\u0022);\n\n// display histogram distribution curve as a line plot\ndouble[] densities = ScottPlot.Statistics.Common.ProbabilityDensity(values, binEdges);\nplt.AddScatterLines(\n    xs: binEdges,\n    ys: densities,\n    color: Color.Black,\n    lineWidth: 2,\n    lineStyle: LineStyle.Dash);\n\n// customize the plot style\nplt.Title(\u0022Adult Male Height\u0022);\nplt.YAxis.Label(\u0022Probability\u0022);\nplt.XAxis.Label(\u0022Height (cm)\u0022);\nplt.SetAxisLimits(yMin: 0);\n\nplt.SaveFig(\u0022stats_histogramProbability.png\u0022);"
    },
    {
      "id": "stats_histogramMultiAxis",
      "category": "Statistics",
      "title": "Histogram Multi-Axis",
      "description": "This example demonstrates how to display a histogram counts on the primary Y axis and the probability curve on the secondary Y axis.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// generate sample heights are based on https://ourworldindata.org/human-height\nRandom rand = new(0);\ndouble[] values = ScottPlot.DataGen.RandomNormal(rand, pointCount: 1234, mean: 178.4, stdDev: 7.6);\n\n// create a histogram\n(double[] counts, double[] binEdges) = ScottPlot.Statistics.Common.Histogram(values, min: 140, max: 220, binSize: 1);\ndouble[] leftEdges = binEdges.Take(binEdges.Length - 1).ToArray();\n\n// display histogram probabability as a bar plot\nvar bar = plt.AddBar(values: counts, positions: leftEdges);\nbar.BarWidth = .6;\nbar.FillColor = ColorTranslator.FromHtml(\u0022#9bc3eb\u0022);\nbar.BorderLineWidth = 0;\n\n// display histogram distribution curve as a line plot on a secondary Y axis\ndouble[] densities = ScottPlot.Statistics.Common.ProbabilityDensity(values, binEdges, percent: true);\nvar probPlot = plt.AddScatterLines(\n    xs: binEdges,\n    ys: densities,\n    lineWidth: 2);\nprobPlot.YAxisIndex = 1;\nplt.YAxis2.Ticks(true);\nplt.YAxis2.Color(probPlot.Color);\n\n// customize the plot style\nplt.Title(\u0022Adult Male Height\u0022);\nplt.YAxis.Label(\u0022Count (#)\u0022);\nplt.YAxis2.Label(\u0022Probability (%)\u0022);\nplt.XAxis.Label(\u0022Height (cm)\u0022);\nplt.SetAxisLimits(yMin: 0);\nplt.SetAxisLimits(yMin: 0, yAxisIndex: 1);\n\nplt.SaveFig(\u0022stats_histogramMultiAxis.png\u0022);"
    },
    {
      "id": "stats_histogramStdev",
      "category": "Statistics",
      "title": "Histogram Stdev",
      "description": "This example demonstrates how to display a histogram with labeled mean and standard deviations.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// generate sample heights are based on https://ourworldindata.org/human-height\nRandom rand = new(0);\ndouble[] values = ScottPlot.DataGen.RandomNormal(rand, pointCount: 1234, mean: 178.4, stdDev: 7.6);\n\n// create a histogram\n(double[] counts, double[] binEdges) = ScottPlot.Statistics.Common.Histogram(values, min: 140, max: 220, binSize: 1);\ndouble[] leftEdges = binEdges.Take(binEdges.Length - 1).ToArray();\n\n// display histogram probabability as a bar plot\nvar bar = plt.AddBar(values: counts, positions: leftEdges);\nbar.FillColor = ColorTranslator.FromHtml(\u0022#9bc3eb\u0022);\nbar.BorderLineWidth = 0;\n\n// display histogram distribution curve as a line plot on a secondary Y axis\ndouble[] smoothEdges = ScottPlot.DataGen.Range(start: binEdges.First(), stop: binEdges.Last(), step: 0.1, includeStop: true);\ndouble[] smoothDensities = ScottPlot.Statistics.Common.ProbabilityDensity(values, smoothEdges, percent: true);\nvar probPlot = plt.AddScatterLines(\n    xs: smoothEdges,\n    ys: smoothDensities,\n    lineWidth: 2,\n    label: \u0022probability\u0022);\nprobPlot.YAxisIndex = 1;\nplt.YAxis2.Ticks(true);\n\n// display vertical lines at points of interest\nvar stats = new ScottPlot.Statistics.BasicStats(values);\n\nplt.AddVerticalLine(stats.Mean, Color.Black, 2, LineStyle.Solid, \u0022mean\u0022);\n\nplt.AddVerticalLine(stats.Mean - stats.StDev, Color.Black, 2, LineStyle.Dash, \u00221 SD\u0022);\nplt.AddVerticalLine(stats.Mean \u002B stats.StDev, Color.Black, 2, LineStyle.Dash);\n\nplt.AddVerticalLine(stats.Mean - stats.StDev * 2, Color.Black, 2, LineStyle.Dot, \u00222 SD\u0022);\nplt.AddVerticalLine(stats.Mean \u002B stats.StDev * 2, Color.Black, 2, LineStyle.Dot);\n\nplt.AddVerticalLine(stats.Min, Color.Gray, 1, LineStyle.Dash, \u0022min/max\u0022);\nplt.AddVerticalLine(stats.Max, Color.Gray, 1, LineStyle.Dash);\n\nplt.Legend(location: Alignment.UpperRight);\n\n// customize the plot style\nplt.Title(\u0022Adult Male Height\u0022);\nplt.YAxis.Label(\u0022Count (#)\u0022);\nplt.YAxis2.Label(\u0022Probability (%)\u0022);\nplt.XAxis.Label(\u0022Height (cm)\u0022);\nplt.SetAxisLimits(yMin: 0);\nplt.SetAxisLimits(yMin: 0, yAxisIndex: 1);\n\nplt.SaveFig(\u0022stats_histogramStdev.png\u0022);"
    },
    {
      "id": "stats_histogram2",
      "category": "Statistics",
      "title": "Multiple Histograms",
      "description": "This example demonstrates two histograms on the same plot. Note the use of fractional units on the vertical axis, allowing easy comparison of datasets with different numbers of points. Unlike the previous example, this one does not use multiple axes.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// male and female heights are based on https://ourworldindata.org/human-height\nRandom rand = new(0);\ndouble[] heightsMale = ScottPlot.DataGen.RandomNormal(rand, pointCount: 2345, mean: 178.4, stdDev: 7.6);\ndouble[] heightsFemale = ScottPlot.DataGen.RandomNormal(rand, pointCount: 1234, mean: 164.7, stdDev: 7.1);\n\n// calculate histograms for male and female datasets\n(double[] probMale, double[] binEdges) = ScottPlot.Statistics.Common.Histogram(heightsMale, min: 140, max: 210, binSize: 1, density: true);\n(double[] probFemale, _) = ScottPlot.Statistics.Common.Histogram(heightsFemale, min: 140, max: 210, binSize: 1, density: true);\ndouble[] leftEdges = binEdges.Take(binEdges.Length - 1).ToArray();\n\n// convert probabilities to percents\nprobMale = probMale.Select(x =\u003E x * 100).ToArray();\nprobFemale = probFemale.Select(x =\u003E x * 100).ToArray();\n\n// plot histograms\nvar barMale = plt.AddBar(values: probMale, positions: leftEdges);\nbarMale.BarWidth = 1;\nbarMale.FillColor = Color.FromArgb(50, Color.Blue);\nbarMale.BorderLineWidth = 0;\n\nvar barFemale = plt.AddBar(values: probFemale, positions: leftEdges);\nbarFemale.BarWidth = 1;\nbarFemale.FillColor = Color.FromArgb(50, Color.Red);\nbarFemale.BorderLineWidth = 0;\n\n// plot probability function curves\ndouble[] pdfMale = ScottPlot.Statistics.Common.ProbabilityDensity(heightsMale, binEdges, percent: true);\nplt.AddScatterLines(\n    xs: binEdges,\n    ys: pdfMale,\n    color: Color.FromArgb(150, Color.Blue),\n    lineWidth: 3,\n    label: $\u0022Male (n={heightsMale.Length:N0})\u0022);\n\ndouble[] pdfFemale = ScottPlot.Statistics.Common.ProbabilityDensity(heightsFemale, binEdges, percent: true);\nplt.AddScatterLines(\n    xs: binEdges,\n    ys: pdfFemale,\n    color: Color.FromArgb(150, Color.Red),\n    lineWidth: 3,\n    label: $\u0022Female (n={heightsFemale.Length:N0})\u0022);\n\n// customize styling\nplt.Title(\u0022Human Height by Sex\u0022);\nplt.YLabel(\u0022Probability (%)\u0022);\nplt.XLabel(\u0022Height (cm)\u0022);\nplt.Legend(location: ScottPlot.Alignment.UpperLeft);\nplt.SetAxisLimits(yMin: 0);\n\nplt.SaveFig(\u0022stats_histogram2.png\u0022);"
    },
    {
      "id": "stats_cph",
      "category": "Statistics",
      "title": "CPH",
      "description": "This example demonstrates how to plot a cumulative probability histogram (CPH) to compare the distribution of two datasets.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// create sample data for two datasets\nRandom rand = new Random(0);\ndouble[] values1 = DataGen.RandomNormal(rand, pointCount: 1000, mean: 50, stdDev: 20);\ndouble[] values2 = DataGen.RandomNormal(rand, pointCount: 1000, mean: 45, stdDev: 25);\n(double[] hist1, double[] binEdges) = ScottPlot.Statistics.Common.Histogram(values1, min: 0, max: 100, binSize: 1, density: true);\n(double[] hist2, _) = ScottPlot.Statistics.Common.Histogram(values2, min: 0, max: 100, binSize: 1, density: true);\ndouble[] cph1 = ScottPlot.Statistics.Common.CumulativeSum(hist1);\ndouble[] cph2 = ScottPlot.Statistics.Common.CumulativeSum(hist2);\ndouble[] leftEdges = binEdges.Take(binEdges.Length - 1).ToArray();\n\n// display datasets as step plots\nplt.AddScatterStep(xs: leftEdges, ys: cph1, label: \u0022Sample A\u0022);\nplt.AddScatterStep(xs: leftEdges, ys: cph2, label: \u0022Sample B\u0022);\n\n// decorate the plot\nplt.Legend();\nplt.SetAxisLimits(yMin: 0, yMax: 1);\nplt.Title(\u0022Cumulative Probability Histogram\u0022);\nplt.XAxis.Label(\u0022Probability (fraction)\u0022);\nplt.YAxis.Label(\u0022Value (units)\u0022);\n\nplt.SaveFig(\u0022stats_cph.png\u0022);"
    },
    {
      "id": "stats_linearRegression",
      "category": "Statistics",
      "title": "Linear Regression",
      "description": "A regression module is available to simplify the act of creating a linear regression line fitted to the data.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// Create some linear but noisy data\ndouble[] ys = DataGen.NoisyLinear(null, pointCount: 100, noise: 30);\ndouble[] xs = DataGen.Consecutive(ys.Length);\ndouble x1 = xs[0];\ndouble x2 = xs[xs.Length - 1];\n\n// use the linear regression fitter to fit these data\nvar model = new ScottPlot.Statistics.LinearRegressionLine(xs, ys);\n\n// plot the original data and add the regression line\nplt.Title(\u0022Linear Regression\\n\u0022 \u002B\n    $\u0022Y = {model.slope:0.0000}x \u002B {model.offset:0.0} \u0022 \u002B\n    $\u0022(R\u00B2 = {model.rSquared:0.0000})\u0022);\nplt.AddScatter(xs, ys, lineWidth: 0);\nplt.AddLine(model.slope, model.offset, (x1, x2), lineWidth: 2);\n\nplt.SaveFig(\u0022stats_linearRegression.png\u0022);"
    },
    {
      "id": "stats_orderStatistics",
      "category": "Statistics",
      "title": "Nth Order Statistics",
      "description": "The Nth order statistic of a set is the Nth smallest value of the set (indexed from 1).",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nRandom rand = new Random(0);\nint pointCount = 500;\ndouble[] xs = DataGen.Consecutive(pointCount);\ndouble[] ys = DataGen.Random(rand, pointCount);\n\nint n = 200;\ndouble nthValue = Statistics.Common.NthOrderStatistic(ys, n);\n\nplt.Title($\u0022{n}th Smallest Value (of {pointCount})\u0022);\nplt.AddScatter(xs, ys, lineWidth: 0, markerShape: MarkerShape.openCircle);\nplt.AddHorizontalLine(nthValue, width: 3, style: LineStyle.Dash);\n\nplt.SaveFig(\u0022stats_orderStatistics.png\u0022);"
    },
    {
      "id": "stats_percentiles",
      "category": "Statistics",
      "title": "Percentiles",
      "description": "Percentiles are a good tool to analyze the distribution of your data and filter out extreme values.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nRandom rand = new Random(0);\nint pointCount = 500;\ndouble[] xs = DataGen.Consecutive(pointCount);\ndouble[] ys = DataGen.Random(rand, pointCount);\n\ndouble tenthPercentile = Statistics.Common.Percentile(ys, 10);\n\nplt.Title(\u002210th Percentile\u0022);\nplt.AddScatter(xs, ys, lineWidth: 0, markerShape: MarkerShape.openCircle);\nplt.AddHorizontalLine(tenthPercentile, width: 3, style: LineStyle.Dash);\n\nplt.SaveFig(\u0022stats_percentiles.png\u0022);"
    },
    {
      "id": "stats_quantiles",
      "category": "Statistics",
      "title": "Quantiles",
      "description": "A q-Quantile is a generalization of quartiles and percentiles to any number of buckets.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nRandom rand = new Random(0);\nint pointCount = 500;\ndouble[] xs = DataGen.Consecutive(pointCount);\ndouble[] ys = DataGen.Random(rand, pointCount);\n\n// A septile is a 7-quantile\ndouble secondSeptile = Statistics.Common.Quantile(ys, 2, 7);\n\nplt.Title(\u0022Second Septile\u0022);\nplt.AddScatter(xs, ys, lineWidth: 0, markerShape: MarkerShape.openCircle);\nplt.AddHorizontalLine(secondSeptile, width: 3, style: LineStyle.Dash);\n\nplt.SaveFig(\u0022stats_quantiles.png\u0022);"
    },
    {
      "id": "style_Default",
      "category": "Style",
      "title": "Default Style",
      "description": "Customize many plot features using style presets",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\nplt.Style(Style.Default);\nplt.Title(\u0022Style.Default\u0022);\nplt.XLabel(\u0022Horizontal Axis\u0022);\nplt.YLabel(\u0022Vertical Axis\u0022);\n\nplt.SaveFig(\u0022style_Default.png\u0022);"
    },
    {
      "id": "style_monospace",
      "category": "Style",
      "title": "Monospace Style",
      "description": "Customize many plot features using style presets",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\nplt.Style(Style.Monospace);\nplt.Title(\u0022Style.Monospace\u0022);\nplt.XLabel(\u0022Horizontal Axis\u0022);\nplt.YLabel(\u0022Vertical Axis\u0022);\n\nplt.SaveFig(\u0022style_monospace.png\u0022);"
    },
    {
      "id": "style_blue1",
      "category": "Style",
      "title": "Blue1 Style",
      "description": "Customize many plot features using style presets",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\nplt.Style(Style.Blue1);\nplt.Title(\u0022Style.Blue1\u0022);\nplt.XLabel(\u0022Horizontal Axis\u0022);\nplt.YLabel(\u0022Vertical Axis\u0022);\n\nplt.SaveFig(\u0022style_blue1.png\u0022);"
    },
    {
      "id": "style_blue2",
      "category": "Style",
      "title": "Blue2 Style",
      "description": "Customize many plot features using style presets",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\nplt.Style(Style.Blue2);\nplt.Title(\u0022Style.Blue2\u0022);\nplt.XLabel(\u0022Horizontal Axis\u0022);\nplt.YLabel(\u0022Vertical Axis\u0022);\n\nplt.SaveFig(\u0022style_blue2.png\u0022);"
    },
    {
      "id": "style_light1",
      "category": "Style",
      "title": "Light1 Style",
      "description": "Customize many plot features using style presets",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\nplt.Style(Style.Light1);\nplt.Title(\u0022Style.Light1\u0022);\nplt.XLabel(\u0022Horizontal Axis\u0022);\nplt.YLabel(\u0022Vertical Axis\u0022);\n\nplt.SaveFig(\u0022style_light1.png\u0022);"
    },
    {
      "id": "style_Gray1",
      "category": "Style",
      "title": "Gray1 Style",
      "description": "Customize many plot features using style presets",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\nplt.Style(Style.Gray1);\nplt.Title(\u0022Style.Gray1\u0022);\nplt.XLabel(\u0022Horizontal Axis\u0022);\nplt.YLabel(\u0022Vertical Axis\u0022);\n\nplt.SaveFig(\u0022style_Gray1.png\u0022);"
    },
    {
      "id": "style_Black",
      "category": "Style",
      "title": "Black Style",
      "description": "Customize many plot features using style presets",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\nplt.Style(Style.Black);\nplt.Title(\u0022Style.Black\u0022);\nplt.XLabel(\u0022Horizontal Axis\u0022);\nplt.YLabel(\u0022Vertical Axis\u0022);\n\nplt.SaveFig(\u0022style_Black.png\u0022);"
    },
    {
      "id": "style_Seaborn",
      "category": "Style",
      "title": "Seaborn Style",
      "description": "Customize many plot features using style presets",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\nplt.Style(Style.Seaborn);\nplt.Title(\u0022Style.Seaborn\u0022);\nplt.XLabel(\u0022Horizontal Axis\u0022);\nplt.YLabel(\u0022Vertical Axis\u0022);\n\nplt.SaveFig(\u0022style_Seaborn.png\u0022);"
    },
    {
      "id": "annotation_quickstart",
      "category": "Plottable: Annotation",
      "title": "Figure Annotations",
      "description": "Annotations are labels placed at a X/Y location on the figure (not coordinates of the data area). Unlike the Text plottable, annotations do not move as the axes are adjusted.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] xs = DataGen.Range(0, 5, .1);\nplt.AddScatter(xs, DataGen.Sin(xs));\nplt.AddScatter(xs, DataGen.Cos(xs));\n\n// default placement is upper left\nplt.AddAnnotation(\u0022Top Left\u0022, 10, 10);\n\n// negative coordinates can be used to place text along different edges\nplt.AddAnnotation(\u0022Lower Left\u0022, 10, -10);\nplt.AddAnnotation(\u0022Top Right\u0022, -10, 10);\nplt.AddAnnotation(\u0022Lower Right\u0022, -10, -10);\n\n// Additional customizations are available\nvar fancy = plt.AddAnnotation(\u0022Fancy Annotation\u0022, 10, 40);\nfancy.Font.Size = 24;\nfancy.Font.Name = \u0022Impact\u0022;\nfancy.Font.Color = Color.Red;\nfancy.Shadow = false;\nfancy.BackgroundColor = Color.FromArgb(25, Color.Blue);\nfancy.BorderWidth = 2;\nfancy.BorderColor = Color.Magenta;\n\nplt.SaveFig(\u0022annotation_quickstart.png\u0022);"
    },
    {
      "id": "plottable_arrow_quickstart",
      "category": "Plottable: Arrow",
      "title": "Arrows",
      "description": "Arrows point to specific locations on the plot. ",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// plot some sample data\nplt.AddSignal(DataGen.Sin(51));\n\n// add arrows using coordinates\nplt.AddArrow(25, 0, 27, .2);\n\n// you can define a minimum length so the line persists even when zooming out\nvar arrow2 = plt.AddArrow(27, -.25, 23, -.5);\narrow2.Color = System.Drawing.Color.Red;\narrow2.MinimumLengthPixels = 100;\n\n// the shape of the arrowhead can be adjusted\nvar skinny = plt.AddArrow(12, 1, 12, .5);\nskinny.Color = System.Drawing.Color.Green;\nskinny.ArrowheadLength = 5;\nskinny.ArrowheadWidth = 2;\n\nvar fat = plt.AddArrow(20, .6, 20, 1);\nfat.Color = System.Drawing.Color.Blue;\nfat.ArrowheadLength = 2;\nfat.ArrowheadWidth = 5;\n\n// a marker can be drawn at the base of the arrow\nvar arrow3 = plt.AddArrow(30, -.58, 35, -.4);\narrow3.MarkerSize = 15;\n\nplt.SaveFig(\u0022plottable_arrow_quickstart.png\u0022);"
    },
    {
      "id": "axisLine_basics",
      "category": "Plottable: Axis Line and Span",
      "title": "Axis Line",
      "description": "An axis line marks a position on an axis. Axis lines extend to positive and negative infinity on the other axis.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// plot sample data\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\n// add axis lines\nplt.AddHorizontalLine(.85);\nplt.AddVerticalLine(23);\n\n// customize axis lines with optional arguments\nplt.AddVerticalLine(x: 33, color: Color.Magenta, width: 3, style: LineStyle.Dot);\n\nplt.SaveFig(\u0022axisLine_basics.png\u0022);"
    },
    {
      "id": "axisLine_finite",
      "category": "Plottable: Axis Line and Span",
      "title": "Finite Axis Line",
      "description": "Axis lines can have lower and/or upper bounds. This can be useful for labeling points of interest.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.AddFunction(x =\u003E Math.Pow(x, 2), lineStyle: LineStyle.Dash);\nplt.AddFunction(x =\u003E Math.Sqrt(x), lineStyle: LineStyle.Dash);\n\n// mark a coordinate from the lower left\nvar point1 = plt.AddPoint(1, 1, size: 10, shape: MarkerShape.openCircle);\nvar hLine1 = plt.AddHorizontalLine(1, width: 2);\nhLine1.Max = 1;\nhLine1.Color = point1.Color;\nvar vLine1 = plt.AddVerticalLine(1, width: 2);\nvLine1.Max = 1;\nvLine1.Color = point1.Color;\n\n// use finate upper and lower limits draw a cross on a point\nvar point2 = plt.AddPoint(4, 2, size: 10, shape: MarkerShape.openCircle);\nvar vLine2 = plt.AddVerticalLine(4, width: 2);\nvLine2.Min = 1.5;\nvLine2.Max = 2.5;\nvLine2.Color = point2.Color;\nvar hLine2 = plt.AddHorizontalLine(2, width: 2);\nhLine2.Min = 3.5;\nhLine2.Max = 4.5;\nhLine2.Color = point2.Color;\n\n// mark a coordinate from the top right\nvar point3 = plt.AddPoint(2, 4, size: 10, shape: MarkerShape.openCircle);\nvar hLine3 = plt.AddHorizontalLine(4, width: 2);\nhLine3.Min = 2;\nhLine3.Color = point3.Color;\nvar vLine3 = plt.AddVerticalLine(2, width: 2);\nvLine3.Min = 4;\nvLine3.Color = point3.Color;\n\nplt.SetAxisLimits(0, 5, 0, 5);\n\nplt.SaveFig(\u0022axisLine_finite.png\u0022);"
    },
    {
      "id": "axisLine_draggable",
      "category": "Plottable: Axis Line and Span",
      "title": "Draggable Axis Lines",
      "description": "In GUI environments, axis lines can be draggable and moved with the mouse. Drag limits define the boundaries the lines can be dragged.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// plot sample data\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\n// add axis lines and configure their drag settings\nvar hLine = plt.AddHorizontalLine(.85);\nhLine.DragEnabled = true;\nhLine.DragLimitMin = -1;\nhLine.DragLimitMax = 1;\n\nvar vLine = plt.AddVerticalLine(23);\nvLine.DragEnabled = true;\nvLine.DragLimitMin = 0;\nvLine.DragLimitMax = 50;\n\n// you can access the position of an axis line at any time\nstring message = $\u0022Vertical line is at X={vLine.X}\u0022;\n\nplt.SaveFig(\u0022axisLine_draggable.png\u0022);"
    },
    {
      "id": "axisLine_positionLabels",
      "category": "Plottable: Axis Line and Span",
      "title": "Position Labels",
      "description": "Axis line positions can be labeled on the axis on top of axis ticks and tick labels. Custom position formatters allow for full customization of the text displayed in these labels. If using a DateTime axis, implement a custom formatter that uses DateTime.FromOADate().",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\nvar hline = plt.AddHorizontalLine(.85);\nhline.LineWidth = 2;\nhline.PositionLabel = true;\nhline.PositionLabelBackground = hline.Color;\nhline.DragEnabled = true;\n\nvar vline = plt.AddVerticalLine(23);\nvline.LineWidth = 2;\nvline.PositionLabel = true;\nvline.PositionLabelBackground = vline.Color;\nvline.DragEnabled = true;\n\nFunc\u003Cdouble, string\u003E xFormatter = x =\u003E $\u0022X={x:F2}\u0022;\nvline.PositionFormatter = xFormatter;\n\nplt.SaveFig(\u0022axisLine_positionLabels.png\u0022);"
    },
    {
      "id": "axisSpan_quickstart",
      "category": "Plottable: Axis Line and Span",
      "title": "Axis Span",
      "description": "Axis spans shade a portion of one axis. Axis spans extend to negative and positive infinity on the other axis.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// plot sample data\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\n// add axis spans\nplt.AddVerticalSpan(.15, .85);\nplt.AddHorizontalSpan(10, 25);\n\nplt.SaveFig(\u0022axisSpan_quickstart.png\u0022);"
    },
    {
      "id": "axisSpan_draggable",
      "category": "Plottable: Axis Line and Span",
      "title": "Draggable Axis Span",
      "description": "Axis spans can be dragged using the mouse. Drag limits are boundaries over which the edges of spans cannot cross.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// plot sample data\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\n// dragging can be enabled and optionally limited to a range\nvar vSpan = plt.AddVerticalSpan(.15, .85);\nvSpan.DragEnabled = true;\nvSpan.DragLimitMin = -1;\nvSpan.DragLimitMax = 1;\nvSpan.BorderColor = Color.Red;\nvSpan.BorderLineStyle = LineStyle.Dot;\nvSpan.BorderLineWidth = 2;\nvSpan.HatchColor = Color.FromArgb(100, Color.Blue);\nvSpan.HatchStyle = Drawing.HatchStyle.SmallCheckerBoard;\nvSpan.Label = \u0022Customized vSpan\u0022;\n\n\n// spans can be configured to allow dragging but disallow resizing\nvar hSpan = plt.AddHorizontalSpan(10, 25);\nhSpan.DragEnabled = true;\nhSpan.DragFixedSize = true;\nhSpan.Label = \u0022Standard hSpan\u0022;\nplt.Legend(true);\n\nplt.SaveFig(\u0022axisSpan_draggable.png\u0022);"
    },
    {
      "id": "axisSpan_ignore",
      "category": "Plottable: Axis Line and Span",
      "title": "Ignore Axis Limits",
      "description": "Calling Plot.AxisAuto (or middle-clicking the plot) will set the axis limits automatically to fit the data on the plot. By default the position of axis lines and spans are included in automatic axis limit calculations, but setting the \u0027\u0027 flag can disable this behavior.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\nvar hline = plt.AddHorizontalLine(0.23);\nhline.DragEnabled = true;\nhline.IgnoreAxisAuto = true;\n\nvar hSpan = plt.AddHorizontalSpan(-10, 20);\nhSpan.DragEnabled = true;\nhSpan.IgnoreAxisAuto = true;\n\nplt.SaveFig(\u0022axisSpan_ignore.png\u0022);"
    },
    {
      "id": "repeatingAxisLine_basics",
      "category": "Plottable: Axis Line and Span",
      "title": "Repeating Axis Line",
      "description": "Repeating axis lines allows to plot several axis lines, either horizontal or vertical, draggable or not, whose positions are linked",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n//Generate a single signal containing 3 harmonic signals\nint sampleCount = 500;\ndouble[] signal1 = ScottPlot.DataGen.Sin(sampleCount, 10);\ndouble[] signal2 = ScottPlot.DataGen.Sin(sampleCount, 20);\ndouble[] signal3 = ScottPlot.DataGen.Sin(sampleCount, 30);\n\ndouble[] signal = new double[sampleCount];\nfor (int index = 0; index \u003C sampleCount; index\u002B\u002B)\n{\n    signal[index] = signal1[index] \u002B signal2[index] \u002B signal3[index];\n}\n\n// Plot the signal\nplt.AddSignal(signal);\n\n// Create a draggable RepeatingVLine with 5 lines spaced evenly by 50 X units, starting at position 0\n// The first line will be thicker than the others\nScottPlot.Plottable.RepeatingVLine vlines1 = new();\nvlines1.DragEnabled = true;\nvlines1.count = 5;\nvlines1.shift = 50;\nvlines1.Color = System.Drawing.Color.Magenta;\nvlines1.LineWidth = 2;\nvlines1.LineStyle = LineStyle.Dash;\nvlines1.PositionLabel = true;\nvlines1.PositionLabelBackground = vlines1.Color;\nvlines1.relativeposition = false;\nplt.Add(vlines1);\n\n// Create a draggable RepeatingVLine with 5 lines spaced evenly by 50 X units, starting at position 0, with a -4 offset\n// The first line will be thicker than the others\nScottPlot.Plottable.RepeatingVLine vlines2 = new();\nvlines2.DragEnabled = true;\nvlines2.count = 3;\nvlines2.shift = 50;\nvlines2.offset = -1;\nvlines2.Color = System.Drawing.Color.DarkGreen;\nvlines2.LineWidth = 2;\nvlines2.LineStyle = LineStyle.Dot;\nvlines2.PositionLabel = true;\nvlines2.PositionLabelBackground = vlines2.Color;\nvlines2.relativeposition = false;\nplt.Add(vlines2);\n\nplt.SetAxisLimitsX(-100, 300);\n\nplt.SaveFig(\u0022repeatingAxisLine_basics.png\u0022);"
    },
    {
      "id": "axisLine_Vector",
      "category": "Plottable: Axis Line and Span",
      "title": "Axis Line Vector",
      "description": "An AxisLineVector allows to setup a series of VLines or HLines, without hassle.These lines can optionally be dragged as their counterparts",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nRandom rand = new Random(0);\ndouble[] xs = DataGen.Random(rand, 50);\ndouble[] ys = DataGen.Random(rand, 50);\n\nvar scatter = plt.AddScatterPoints(xs, ys, Color.Blue, 10);\n\nvar vlines = new ScottPlot.Plottable.VLineVector();\nvlines.Xs = new double[] { xs[1], xs[12], xs[35] };\nvlines.Color = Color.Red;\nvlines.PositionLabel = true;\nvlines.PositionLabelBackground = vlines.Color;\n\nvar hlines = new ScottPlot.Plottable.HLineVector();\nhlines.Ys = new double[] { ys[1], ys[12], ys[35] };\nhlines.Color = Color.DarkCyan;\nhlines.PositionLabel = true;\nhlines.PositionLabelBackground = hlines.Color;\nhlines.DragEnabled = true;\n\nplt.Add(scatter);\nplt.Add(vlines);\nplt.Add(hlines);\n\nplt.SaveFig(\u0022axisLine_Vector.png\u0022);"
    },
    {
      "id": "bar_quickstart",
      "category": "Plottable: Bar Graph",
      "title": "Bar Graph",
      "description": "A simple bar graph can be created from a series of values. By default values are palced at X positions 0, 1, 2, etc.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// create sample data\ndouble[] values = { 26, 20, 23, 7, 16 };\n\n// add a bar graph to the plot\nplt.AddBar(values);\n\n// adjust axis limits so there is no padding below the bar graph\nplt.SetAxisLimits(yMin: 0);\n\nplt.SaveFig(\u0022bar_quickstart.png\u0022);"
    },
    {
      "id": "bar_positions",
      "category": "Plottable: Bar Graph",
      "title": "Bar Graph with Defined Positions",
      "description": "Horizontal positions for each bar can be defined manually. If you define bar positions, you will probably want to define the bar width as well.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// create sample data\ndouble[] values = { 26, 20, 23, 7, 16 };\ndouble[] positions = { 10, 20, 30, 40, 50 };\n\n// add a bar graph to the plot\nvar bar = plt.AddBar(values, positions);\n\n// customize the width of bars (80% of the inter-position distance looks good)\nbar.BarWidth = (positions[1] - positions[0]) * .8;\n\n// adjust axis limits so there is no padding below the bar graph\nplt.SetAxisLimits(yMin: 0);\n\nplt.SaveFig(\u0022bar_positions.png\u0022);"
    },
    {
      "id": "bar_labels",
      "category": "Plottable: Bar Graph",
      "title": "Bar Labels",
      "description": "Bars placed at specific positions can be labeled by setting tick labels for those positions.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] values = { 26, 20, 23, 7, 16 };\ndouble[] positions = { 0, 1, 2, 3, 4 };\nstring[] labels = { \u0022PHP\u0022, \u0022JS\u0022, \u0022C\u002B\u002B\u0022, \u0022GO\u0022, \u0022VB\u0022 };\nplt.AddBar(values, positions);\nplt.XTicks(positions, labels);\nplt.SetAxisLimits(yMin: 0);\n\nplt.SaveFig(\u0022bar_labels.png\u0022);"
    },
    {
      "id": "bar_error",
      "category": "Plottable: Bar Graph",
      "title": "Bar Graph with Error Bars",
      "description": "Errorbars can be added to any bar graph.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// add a bar graph to the plot\ndouble[] values = { 26, 20, 23, 7, 16 };\nvar bar = plt.AddBar(values);\n\n// add errorbars to the bar graph and customize styling as desired\ndouble[] errors = { 3, 2, 5, 1, 3 };\nbar.ValueErrors = errors;\nbar.ErrorCapSize = .1;\n\n// adjust axis limits so there is no padding below the bar graph\nplt.SetAxisLimits(yMin: 0);\n\nplt.SaveFig(\u0022bar_error.png\u0022);"
    },
    {
      "id": "bar_stacked",
      "category": "Plottable: Bar Graph",
      "title": "Stacked Bar Graphs",
      "description": "Bars can be overlapped to give the appearance of stacking.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// create sample data\ndouble[] valuesA = { 1, 2, 3, 2, 1, 2, 1 };\ndouble[] valuesB = { 3, 3, 2, 1, 3, 2, 1 };\n\n// to simulate stacking B on A, shift B up by A\ndouble[] valuesB2 = new double[valuesB.Length];\nfor (int i = 0; i \u003C valuesB.Length; i\u002B\u002B)\n    valuesB2[i] = valuesA[i] \u002B valuesB[i];\n\n// plot the bar charts in reverse order (highest first)\nplt.AddBar(valuesB2);\nplt.AddBar(valuesA);\n\n// adjust axis limits so there is no padding below the bar graph\nplt.SetAxisLimits(yMin: 0);\n\nplt.SaveFig(\u0022bar_stacked.png\u0022);"
    },
    {
      "id": "bar_values",
      "category": "Plottable: Bar Graph",
      "title": "Values Above Bars",
      "description": "The value of each bar can be displayed above it.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// create sample data\ndouble[] values = { 27.3, 23.1, 21.2, 16.1, 6.4, 19.2, 18.7, 17.3, 20.3, 13.1 };\n\n// add a bar graph to the plot and enable values to be displayed above each bar\nvar bar = plt.AddBar(values);\nbar.ShowValuesAboveBars = true;\n\n// adjust axis limits so there is no padding below the bar graph\nplt.SetAxisLimits(yMin: 0);\n\nplt.SaveFig(\u0022bar_values.png\u0022);"
    },
    {
      "id": "bar_values_custom_formatter",
      "category": "Plottable: Bar Graph",
      "title": "Custom Value Formatter",
      "description": "A custom formatter can be used to generate labels above each bar using the numeric value of the bar itself.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nFunc\u003Cdouble, string\u003E customFormatter = y =\u003E $\u0022Y={y:N2}\u0022;\n\ndouble[] values = { 27.3, 23.1, 21.2, 16.1, 6.4, 19.2, 18.7, 17.3, 20.3, 13.1 };\nvar bar = plt.AddBar(values);\nbar.ShowValuesAboveBars = true;\nbar.ValueFormatter = customFormatter;\n\nplt.SetAxisLimits(yMin: 0);\n\nplt.SaveFig(\u0022bar_values_custom_formatter.png\u0022);"
    },
    {
      "id": "bar_pattern",
      "category": "Plottable: Bar Graph",
      "title": "Bar Fill Pattern",
      "description": "Bar graph fill pattern can be customized.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nvar bar1 = plt.AddBar(new double[] { 10, 13, 15 }, new double[] { 1, 5, 9 });\nbar1.HatchStyle = Drawing.HatchStyle.StripedUpwardDiagonal;\nbar1.FillColor = Color.Gray;\nbar1.FillColorHatch = Color.Black;\nbar1.Label = \u0022Series 1\u0022;\n\nvar bar2 = plt.AddBar(new double[] { 14, 15, 9 }, new double[] { 2, 6, 10 });\nbar2.HatchStyle = Drawing.HatchStyle.StripedWideDownwardDiagonal;\nbar2.FillColor = Color.DodgerBlue;\nbar2.FillColorHatch = Color.DeepSkyBlue;\nbar2.Label = \u0022Series 2\u0022;\n\nvar bar3 = plt.AddBar(new double[] { 13, 6, 14 }, new double[] { 3, 7, 11 });\nbar3.HatchStyle = Drawing.HatchStyle.LargeCheckerBoard;\nbar3.FillColor = Color.SeaGreen;\nbar3.FillColorHatch = Color.DarkSeaGreen;\nbar3.Label = \u0022Series 3\u0022;\n\n// add a legend to display each labeled bar plot\nplt.Legend(location: Alignment.UpperRight);\n\n// adjust axis limits so there is no padding below the bar graph\nplt.SetAxisLimits(yMin: 0, yMax: 20);\n\nplt.SaveFig(\u0022bar_pattern.png\u0022);"
    },
    {
      "id": "bar_horizontal",
      "category": "Plottable: Bar Graph",
      "title": "Horizontal Bar Graph",
      "description": "Bar graphs are typically displayed as columns, but it\u0027s possible to show bars as rows.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// create sample data\ndouble[] values = { 26, 20, 23, 7, 16 };\ndouble[] errors = { 3, 2, 5, 1, 3 };\ndouble[] positions = { 1, 2, 3, 4, 5 };\n\n// add a bar graph to the plot and customize it to render horizontally\nvar bar = plt.AddBar(values, errors, positions);\nbar.Orientation = Orientation.Horizontal;\n\n// adjust axis limits so there is no padding to the left of the bar graph\nplt.SetAxisLimits(xMin: 0);\n\nplt.SaveFig(\u0022bar_horizontal.png\u0022);"
    },
    {
      "id": "bar_group",
      "category": "Plottable: Bar Graph",
      "title": "Grouped Bar Graphs",
      "description": "By customizing positions of multiple bar plots you can achieve the appearance of grouped bar graphs. The AddBarGroups() method is designed to simplify this process. More advanced grouping and bar plot styling is possible using the Population plot type.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// generate random data to plot\nint groupCount = 5;\nRandom rand = new(0);\ndouble[] values1 = DataGen.RandomNormal(rand, groupCount, 20, 5);\ndouble[] values2 = DataGen.RandomNormal(rand, groupCount, 20, 5);\ndouble[] values3 = DataGen.RandomNormal(rand, groupCount, 20, 5);\ndouble[] errors1 = DataGen.RandomNormal(rand, groupCount, 5, 2);\ndouble[] errors2 = DataGen.RandomNormal(rand, groupCount, 5, 2);\ndouble[] errors3 = DataGen.RandomNormal(rand, groupCount, 5, 2);\n\n// group all data together\nstring[] groupNames = { \u0022Group A\u0022, \u0022Group B\u0022, \u0022Group C\u0022, \u0022Group D\u0022, \u0022Group E\u0022 };\nstring[] seriesNames = { \u0022Series 1\u0022, \u0022Series 2\u0022, \u0022Series 3\u0022 };\ndouble[][] valuesBySeries = { values1, values2, values3 };\ndouble[][] errorsBySeries = { errors1, errors2, errors3 };\n\n// add the grouped bar plots and show a legend\nplt.AddBarGroups(groupNames, seriesNames, valuesBySeries, errorsBySeries);\nplt.Legend(location: Alignment.UpperRight);\n\n// adjust axis limits so there is no padding below the bar graph\nplt.SetAxisLimits(yMin: 0);\n\nplt.SaveFig(\u0022bar_group.png\u0022);"
    },
    {
      "id": "bar_yoffset",
      "category": "Plottable: Bar Graph",
      "title": "Bars with Y Offsets",
      "description": "By default bar graphs start at 0, but this does not have to be the case. Y offsets can be defined for each bar. When Y offsets are used, values represent the height of the bars (relative to their offsets).",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] values = { 23, 17, 19, 24, 22 };\ndouble[] yOffsets = { -100, -100, -100, -100, -100 };\n\nvar bar = plt.AddBar(values);\nbar.ValueOffsets = yOffsets;\n\n// adjust axis limits so there is no padding below the bar graph\nplt.SetAxisLimits(yMin: -100);\n\nplt.SaveFig(\u0022bar_yoffset.png\u0022);"
    },
    {
      "id": "bar_yNegColor",
      "category": "Plottable: Bar Graph",
      "title": "Negative Bar Colors",
      "description": "Bars with negative values can be colored differently than positive ones.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] values = { 23, -17, 19, -24, 22 };\n\nvar bar = plt.AddBar(values);\nbar.FillColor = Color.Green;\nbar.FillColorNegative = Color.Red;\n\nplt.SaveFig(\u0022bar_yNegColor.png\u0022);"
    },
    {
      "id": "bar_waterfall",
      "category": "Plottable: Bar Graph",
      "title": "Waterfall Bar Graph",
      "description": "Waterfall bar graphs use bars to represent changes in value from the previous level. This style graph can be created by offseting each bar by the sum of all bars preceeding it. This effect is similar to financial plots (OHLC and Candlestick) which are described in another section.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] values = DataGen.RandomNormal(0, 12, 5, 10);\ndouble[] offsets = Enumerable.Range(0, values.Length).Select(x =\u003E values.Take(x).Sum()).ToArray();\n\nvar bar = plt.AddBar(values);\nbar.ValueOffsets = offsets;\nbar.FillColorNegative = Color.Red;\nbar.FillColor = Color.Green;\n\nplt.SaveFig(\u0022bar_waterfall.png\u0022);"
    },
    {
      "id": "bar_lollipop",
      "category": "Plottable: Bar Graph",
      "title": "Lollipop Plot Quickstart",
      "description": "Lollipop plots convey the same information as Bar plots but have a different appearance.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] values = { 26, 20, 23, 7, 16 };\nplt.AddLollipop(values);\n\nplt.SaveFig(\u0022bar_lollipop.png\u0022);"
    },
    {
      "id": "bar_lollipop_custom",
      "category": "Plottable: Bar Graph",
      "title": "Lollipop Plot Customizations",
      "description": "Lollipop plots can be extensively customized.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] values = { 26, 20, 23, 7, 16 };\nvar lollipop = plt.AddLollipop(values);\nlollipop.Orientation = Orientation.Horizontal;\nlollipop.LollipopRadius = 3;\nlollipop.BorderColor = Color.Green;\nlollipop.LollipopColor = Color.Blue;\nlollipop.LollipopRadius = 10;\n\nplt.SaveFig(\u0022bar_lollipop_custom.png\u0022);"
    },
    {
      "id": "bar_cleveland_dot",
      "category": "Plottable: Bar Graph",
      "title": "Cleveland Dot Plot",
      "description": "Cleveland Dot Plots allow comparing two categories in situations where a Bar Plot may be crowded.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// Data from https://footystats.org/england/premier-league/home-away-league-table\ndouble[] homeWins = { 12, 17, 16, 18, 18 };\ndouble[] awayWins = { 11, 13, 16, 14, 14 };\nstring[] labels = { \u00222015/16\u0022, \u00222016/17\u0022, \u00222017/18\u0022, \u00222018/19\u0022, \u00222019/20\u0022 };\n\nvar clevelandDot = plt.AddClevelandDot(homeWins, awayWins);\nclevelandDot.SetPoint1Style(label: \u0022Home Wins\u0022);\nclevelandDot.SetPoint2Style(label: \u0022Away Wins\u0022, markerShape: MarkerShape.triUp);\n\nplt.XTicks(labels);\nplt.Title(\u0022British Premier League Champion Home vs Away Wins\u0022);\nplt.Legend();\n\nplt.SaveFig(\u0022bar_cleveland_dot.png\u0022);"
    },
    {
      "id": "bar_dateTime",
      "category": "Plottable: Bar Graph",
      "title": "DateTime Bar Plot",
      "description": "Bars have a default width of 1.0, but when using DateTime axis this means bars are one day wide. To plot DateTime data you may need to manually set the width of a bar to a desired size (in fractions of a day).",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// let\u0027s plot 24 hours of data\nint pointCount = 24;\n\n// generate some random values\nvar rand = new Random(0);\ndouble[] values = DataGen.Random(rand, pointCount, 1, 2);\n\n// space every time point by 1 hour from a starting point\nDateTime start = new DateTime(2021, 09, 24, 0, 0, 0);\ndouble[] positions = new double[pointCount];\nfor (int i = 0; i \u003C pointCount; i\u002B\u002B)\n    positions[i] = start.AddHours(i).ToOADate();\n\n// display the bar plot using a time axis\nvar bar = plt.AddBar(values, positions);\nplt.XAxis.DateTimeFormat(true);\n\n// indicate each bar width should be 1/24 of a day then shrink sligtly to add spacing between bars\nbar.BarWidth = (1.0 / 24) * .8;\n\n// adjust axis limits so there is no padding below the bar graph\nplt.SetAxisLimits(yMin: 0);\n\nplt.SaveFig(\u0022bar_dateTime.png\u0022);"
    },
    {
      "id": "bubble_quickstart",
      "category": "Plottable: Bubble",
      "title": "Bubble Plot",
      "description": "Bubble plots display circles at specific X/Y locations. Each circle can be individually customized. Save the object that is returned when the bubble plot is created and call its Add() method to add bubbles.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] xs = DataGen.Consecutive(31);\ndouble[] ys = DataGen.Sin(31);\nvar colormap = Drawing.Colormap.Viridis;\n\nvar myBubblePlot = plt.AddBubblePlot();\nfor (int i = 0; i \u003C xs.Length; i\u002B\u002B)\n{\n    double fraction = (double)i / xs.Length;\n    myBubblePlot.Add(\n        x: xs[i],\n        y: ys[i],\n        radius: 10 \u002B i,\n        fillColor: colormap.GetColor(fraction, alpha: .8),\n        edgeColor: System.Drawing.Color.Black,\n        edgeWidth: 2\n    );\n}\n\nplt.Title(\u0022Advanced Bubble Plot\u0022);\nplt.AxisAuto(.2, .25); // zoom out to accommodate large bubbles\n\nplt.SaveFig(\u0022bubble_quickstart.png\u0022);"
    },
    {
      "id": "bubble_withText",
      "category": "Plottable: Bubble",
      "title": "Bubbles with Labels",
      "description": "Bubble plots can be combined with other plot types to create more advanced charts. In this example each bubble is accompanied by a text object. Bubbles are also colored according to their size such that smaller bubbles are bluer.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nRandom rand = new(0);\nint pointCount = 30;\ndouble[] xs = DataGen.Consecutive(pointCount);\ndouble[] ys = DataGen.Random(rand, pointCount, 10);\nstring[] labels = ys.Select(x =\u003E x.ToString(\u0022N2\u0022)).ToArray();\nvar labelFont = new Drawing.Font\n{\n    Bold = true,\n    Color = Color.Black,\n    Alignment = Alignment.MiddleCenter\n};\n\nvar myBubblePlot = plt.AddBubblePlot();\nfor (int i = 0; i \u003C xs.Length; i\u002B\u002B)\n{\n    // give each bubble a random size and make smaller ones bluer\n    double randomValue = rand.NextDouble();\n    double bubbleSize = randomValue * 30 \u002B 10;\n    Color bubbleColor = Drawing.Colormap.Jet.GetColor(randomValue, .5);\n\n    myBubblePlot.Add(\n        x: xs[i],\n        y: ys[i],\n        radius: bubbleSize,\n        fillColor: bubbleColor,\n        edgeColor: Color.Transparent,\n        edgeWidth: 1\n    );\n\n    plt.AddText(labels[i], xs[i], ys[i], labelFont);\n}\n\nplt.Title(\u0022Bubble Plot with Labels\u0022);\nplt.AxisAuto(.2, .25); // zoom out to accommodate large bubbles\n\nplt.SaveFig(\u0022bubble_withText.png\u0022);"
    },
    {
      "id": "colorbar_quickstart",
      "category": "Plottable: Colorbar",
      "title": "Colorbar",
      "description": "A colorbar displays a colormap beside the data area. Colorbars are typically added to plots containing heatmaps.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.AddColorbar();\n\n// direct attention to the colorbar\nvar text = plt.AddText(\u0022Colorbar\u0022, 5, 0, 24, Color.Red);\ntext.Alignment = Alignment.MiddleRight;\nplt.AddArrow(7, 0, 5, 0, color: Color.Red);\nplt.SetAxisLimits(-10, 10, -10, 10);\n\nplt.SaveFig(\u0022colorbar_quickstart.png\u0022);"
    },
    {
      "id": "colorbar_colormap",
      "category": "Plottable: Colorbar",
      "title": "Colorbar for Colormap",
      "description": "By default colorbars use the Viridis colormap, but this behavior can be customized and many colormaps are available.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.AddColorbar(Drawing.Colormap.Turbo);\n\n// direct attention to the colorbar\nvar text = plt.AddText(\u0022Colorbar\u0022, 5, 0, 24, Color.Red);\ntext.Alignment = Alignment.MiddleRight;\nplt.AddArrow(7, 0, 5, 0, color: Color.Red);\nplt.SetAxisLimits(-10, 10, -10, 10);\n\nplt.SaveFig(\u0022colorbar_colormap.png\u0022);"
    },
    {
      "id": "colorbar_ticks",
      "category": "Plottable: Colorbar",
      "title": "Colorbar Ticks",
      "description": "Tick marks can be added to colorbars. Each tick is described by a position (a fraction of the distance from the bottom to the top) and a string (the tick label).",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nvar cb = plt.AddColorbar(Drawing.Colormap.Turbo);\n\n// Add manual ticks (disabling automatic ticks)\ncb.AddTick(0, \u0022-123\u0022);\ncb.AddTick(1, \u0022\u002B123\u0022);\ncb.AddTick(.5, \u00220\u0022);\ncb.AddTick(.25, \u0022-61.5\u0022);\ncb.AddTick(.75, \u0022\u002B61.5\u0022);\n\n// To re-enable automatic ticks call cb.AutomaticTicks(true)\n\n// direct attention to the colorbar\nvar text = plt.AddText(\u0022Colorbar\u0022, 5, 0, 24, Color.Red);\ntext.Alignment = Alignment.MiddleRight;\nplt.AddArrow(7, 0, 5, 0, color: Color.Red);\nplt.SetAxisLimits(-10, 10, -10, 10);\n\nplt.SaveFig(\u0022colorbar_ticks.png\u0022);"
    },
    {
      "id": "colorbar_Range",
      "category": "Plottable: Colorbar",
      "title": "Color Range",
      "description": "You can restrict a colorbar to only show a small range of a colormap. In this example we only use the middle of a rainbow colormap.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nvar cb = plt.AddColorbar(Drawing.Colormap.Turbo);\ncb.MinValue = -10;\ncb.MaxValue = 10;\ncb.MinColor = .25;\ncb.MaxColor = .75;\n\n// direct attention to the colorbar\nvar text = plt.AddText(\u0022Colorbar\u0022, 5, 0, 24, Color.Red);\ntext.Alignment = Alignment.MiddleRight;\nplt.AddArrow(7, 0, 5, 0, color: Color.Red);\nplt.SetAxisLimits(-10, 10, -10, 10);\n\nplt.SaveFig(\u0022colorbar_Range.png\u0022);"
    },
    {
      "id": "colorbar_clip",
      "category": "Plottable: Colorbar",
      "title": "Clipped value range",
      "description": "If data values extend beyond the min/max range displayed by a colorbar you can indicate the colormap is clipping the data values and inequality symbols will be displayed in the tick labeles at the edge of the colorbar.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nvar cb = plt.AddColorbar(Drawing.Colormap.Turbo);\ncb.MinValue = -10;\ncb.MaxValue = 10;\ncb.MinIsClipped = true;\ncb.MaxIsClipped = true;\n\n// direct attention to the colorbar\nvar text = plt.AddText(\u0022Colorbar\u0022, 5, 0, 24, Color.Red);\ntext.Alignment = Alignment.MiddleRight;\nplt.AddArrow(7, 0, 5, 0, color: Color.Red);\nplt.SetAxisLimits(-10, 10, -10, 10);\n\nplt.SaveFig(\u0022colorbar_clip.png\u0022);"
    },
    {
      "id": "colorbar_scatter",
      "category": "Plottable: Colorbar",
      "title": "Scatter Plot with Colorbar",
      "description": "This example shows how to add differently colored markers to the plot to simulate a scatter plot with points colored according to a colorbar. Note that the colormap generates the colors, and that a colorbar just displays a colormap",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nvar cmap = ScottPlot.Drawing.Colormap.Viridis;\nplt.AddColorbar(cmap);\n\nRandom rand = new(0);\nfor (int i = 0; i \u003C 1000; i\u002B\u002B)\n{\n    double x = ScottPlot.DataGen.RandomNormalValue(rand, mean: 0, stdDev: .5);\n    double y = ScottPlot.DataGen.RandomNormalValue(rand, mean: 0, stdDev: .5);\n    double colorFraction = Math.Sqrt(x * x \u002B y * y);\n    System.Drawing.Color c = ScottPlot.Drawing.Colormap.Viridis.GetColor(colorFraction);\n    plt.AddPoint(x, y, c);\n}\n\nplt.SaveFig(\u0022colorbar_scatter.png\u0022);"
    },
    {
      "id": "colorbar_left",
      "category": "Plottable: Colorbar",
      "title": "Colorbar on Left",
      "description": "A colorbar may be added to the left side of the chart",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.AddColorbar(rightSide: false);\n\nplt.SaveFig(\u0022colorbar_left.png\u0022);"
    },
    {
      "id": "coxcomb_quickstart",
      "category": "Plottable: Coxcomb",
      "title": "Coxcomb Chart",
      "description": "A Pie chart where the angle of slices is constant but the radii are not.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] values = { 11, 16, 7, 3, 14 };\nvar coxcomb = plt.AddCoxcomb(values);\ncoxcomb.FillColors = plt.Palette.GetColors(5, 0, .5);\ncoxcomb.SliceLabels = new string[] { \u0022bikes\u0022, \u0022blimps\u0022, \u0022subs\u0022, \u0022saucers\u0022, \u0022rockets\u0022 };\n\nplt.SaveFig(\u0022coxcomb_quickstart.png\u0022);"
    },
    {
      "id": "coxcomb_iconValue",
      "category": "Plottable: Coxcomb",
      "title": "Coxcomb Chart with icons",
      "description": "A Pie chart where the angle of slices is constant but the radii are not, icons are used for quick reference.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] values = { 11, 16, 7, 3, 14 };\nvar coxcomb = plt.AddCoxcomb(values);\ncoxcomb.CategoryImages = CategoryImages;\ncoxcomb.FillColors = plt.Palette.GetColors(5, 0, .5);\nplt.Legend();\n\nplt.SaveFig(\u0022coxcomb_iconValue.png\u0022);"
    },
    {
      "id": "crosshair_quickstart",
      "category": "Plottable: Crosshair",
      "title": "Crosshair",
      "description": "The Crosshair plot type draws vertical and horizontal lines that intersect at a point on the plot and the coordinates of those lines are displayed on top of the axis ticks. This plot type is typically updated after MouseMove events to track the mouse",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.AddSignal(ScottPlot.DataGen.Sin(51));\nplt.AddSignal(ScottPlot.DataGen.Cos(51));\nplt.AddCrosshair(42, 0.48);\n\nplt.Title(\u0022Crosshair Demo\u0022);\nplt.XLabel(\u0022Horizontal Axis\u0022);\nplt.YLabel(\u0022Vertical Axis\u0022);\n\nplt.SaveFig(\u0022crosshair_quickstart.png\u0022);"
    },
    {
      "id": "crosshair_customize",
      "category": "Plottable: Crosshair",
      "title": "Crosshair Customization",
      "description": "Crosshair styling and label formatting can be customized by accessing public fields.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.Title(\u0022Customized Crosshair\u0022);\nplt.XLabel(\u0022Horizontal Axis\u0022);\nplt.YLabel(\u0022Vertical Axis\u0022);\n\nplt.AddSignal(ScottPlot.DataGen.Sin(51));\nplt.AddSignal(ScottPlot.DataGen.Cos(51));\n\nvar ch = plt.AddCrosshair(42, 0.48);\n\n// you can style both lines at the same time\nch.LineStyle = LineStyle.Dash;\nch.Color = System.Drawing.Color.Blue;\nch.LineWidth = 2;\n\n// or reach in and style lines individually\nch.HorizontalLine.PositionLabelFont.Size = 16;\nch.VerticalLine.PositionLabelFont.Size = 8;\nch.VerticalLine.LineStyle = LineStyle.Dot;\n\nplt.SaveFig(\u0022crosshair_customize.png\u0022);"
    },
    {
      "id": "crosshair_formatting",
      "category": "Plottable: Crosshair",
      "title": "DateTime Axis Label",
      "description": "Crosshair labels display numeric labels by default, but a public field makes it possible to convert positions to DateTime (FromOATime) when generating their axis labels.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.Title(\u0022Crosshair with DateTime Axis\u0022);\nplt.XLabel(\u0022Horizontal Axis\u0022);\nplt.YLabel(\u0022Vertical Axis\u0022);\n\n// plot DateTime data\nint pointCount = 100;\nRandom rand = new Random(0);\ndouble[] values = ScottPlot.DataGen.RandomWalk(rand, pointCount);\nDateTime[] dates = Enumerable.Range(0, pointCount)\n      .Select(x =\u003E new DateTime(2016, 06, 27).AddDays(x))\n      .ToArray();\ndouble[] xs = dates.Select(x =\u003E x.ToOADate()).ToArray();\nplt.AddScatter(xs, values);\n\n// add a crosshair\nvar ch = plt.AddCrosshair(xs[50], values[50]);\n\n// indicaite horizontal axis is DateTime and give a proper DateTime format string\n// https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings\nch.VerticalLine.PositionFormatter = pos =\u003E DateTime.FromOADate(pos).ToString(\u0022d\u0022);\n\n// use a numeric vertical axis but customize the format string\n// https://docs.microsoft.com/en-us/dotnet/standard/base-types/standard-numeric-format-strings\nch.VerticalLine.PositionFormatter = pos =\u003E pos.ToString(\u0022F4\u0022);\n\nplt.SaveFig(\u0022crosshair_formatting.png\u0022);"
    },
    {
      "id": "crosshair_customlabelformatting",
      "category": "Plottable: Crosshair",
      "title": "Custom Label Format",
      "description": "For ultimate control over crosshair label format you can create a custom formatter function and use that to convert positions to labels. This allows logic to be used to format crosshair labels.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.AddSignal(ScottPlot.DataGen.Sin(51));\nplt.AddSignal(ScottPlot.DataGen.Cos(51));\n\nvar ch = plt.AddCrosshair(20, 0);\n\n// create a custom formatter as a static class\nstatic string customFormatter(double position)\n{\n    if (position == 0)\n        return \u0022zero\u0022;\n    else if (position \u003E 0)\n        return $\u0022\u002B{position:F2}\u0022;\n    else\n        return $\u0022({Math.Abs(position):F2})\u0022;\n}\n\n// use the custom formatter for X and Y crosshair labels\nch.HorizontalLine.PositionFormatter = customFormatter;\nch.VerticalLine.PositionFormatter = customFormatter;\n\n// style the plot\nplt.Title(\u0022Crosshair with Custom Label Formmater\u0022);\nplt.XLabel(\u0022Horizontal Axis\u0022);\nplt.YLabel(\u0022Vertical Axis\u0022);\n\nplt.SaveFig(\u0022crosshair_customlabelformatting.png\u0022);"
    },
    {
      "id": "crosshair_multiple_different_axes",
      "category": "Plottable: Crosshair",
      "title": "Crosshairs on Multiple Axes",
      "description": "Crosshairs label coordinates on the primary axes by default, but the axis index can be changed allowing multiple crosshairs to label multiple axes.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// add a signal and crosshair to the primary X and Y axis (index 0)\nvar signal1 = plt.AddSignal(DataGen.RandomWalk(null, 100));\nvar cross1 = plt.AddCrosshair(24, 5.29);\ncross1.LineWidth = 2;\n\n// add a signal and crosshair to the secondary X and Y axis (index 1)\nvar signal2 = plt.AddSignal(DataGen.RandomWalk(null, 50));\nsignal2.YAxisIndex = 1;\nsignal2.XAxisIndex = 1;\n\nvar cross2 = plt.AddCrosshair(33, 5.1);\ncross2.HorizontalLine.PositionLabelOppositeAxis = true;\ncross2.VerticalLine.PositionLabelOppositeAxis = true;\ncross2.YAxisIndex = signal2.YAxisIndex;\ncross2.XAxisIndex = signal2.XAxisIndex;\ncross2.LineStyle = LineStyle.Dot;\ncross2.LineWidth = 2;\n\n// apply signal colors to the crosshairs\ncross1.Color = signal1.Color;\ncross2.Color = signal2.Color;\n\n// add axis labels\nplt.Title(\u0022Multiple Crosshairs for different Axes\u0022);\nplt.XLabel(\u0022Horizontal Axis\u0022);\nplt.YLabel(\u0022Vertical Axis\u0022);\nplt.YAxis2.Label(\u0022Signal2 Value\u0022);\n\n// show ticks for axes where ticks are hidden by default\nplt.YAxis2.Ticks(true);\nplt.XAxis2.Ticks(true);\n\nplt.SaveFig(\u0022crosshair_multiple_different_axes.png\u0022);"
    },
    {
      "id": "errorBar_quickstart",
      "category": "Plottable: Error Bar",
      "title": "Error Bar Quickstart",
      "description": "Error Bars allow more fine-grained control over how your error bars are shown.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nRandom rand = new Random(0);\nint pointCount = 20;\n\ndouble[] xs = DataGen.Consecutive(pointCount);\ndouble[] ys = DataGen.RandomNormal(rand, pointCount, mean: 20, stdDev: 2);\n\ndouble[] xErrPos = DataGen.RandomNormal(rand, pointCount).Select(e =\u003E Math.Abs(e)).ToArray();\ndouble[] xErrNeg = DataGen.RandomNormal(rand, pointCount).Select(e =\u003E Math.Abs(e)).ToArray();\ndouble[] yErrPos = DataGen.RandomNormal(rand, pointCount).Select(e =\u003E Math.Abs(e)).ToArray();\ndouble[] yErrNeg = DataGen.RandomNormal(rand, pointCount).Select(e =\u003E Math.Abs(e)).ToArray();\n\nplt.AddScatter(xs, ys, System.Drawing.Color.Blue, lineStyle: LineStyle.Dot);\nplt.AddErrorBars(xs, ys, xErrPos, xErrNeg, yErrPos, yErrNeg, System.Drawing.Color.Blue);\n\nplt.SaveFig(\u0022errorBar_quickstart.png\u0022);"
    },
    {
      "id": "errorBar_symmetric",
      "category": "Plottable: Error Bar",
      "title": "Symmetric Error Bars",
      "description": "There\u0027s a shorthand method for error bars where the positive and negative error is the same.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nRandom rand = new Random(0);\nint pointCount = 20;\n\ndouble[] xs = DataGen.Consecutive(pointCount);\ndouble[] ys = DataGen.RandomNormal(rand, pointCount, mean: 20, stdDev: 2);\n\ndouble[] xErr = DataGen.RandomNormal(rand, pointCount).Select(e =\u003E Math.Abs(e)).ToArray();\ndouble[] yErr = DataGen.RandomNormal(rand, pointCount).Select(e =\u003E Math.Abs(e)).ToArray();\n\nplt.AddScatter(xs, ys, System.Drawing.Color.Blue, lineStyle: LineStyle.Dot);\nplt.AddErrorBars(xs, ys, xErr, yErr, System.Drawing.Color.Blue);\n\nplt.SaveFig(\u0022errorBar_symmetric.png\u0022);"
    },
    {
      "id": "errorBar_oneDimension",
      "category": "Plottable: Error Bar",
      "title": "Error Bars in One Dimension",
      "description": "If you only have error data for one dimension you can simply pass in null for the other dimension.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nRandom rand = new Random(0);\nint pointCount = 20;\n\ndouble[] xs = DataGen.Consecutive(pointCount);\ndouble[] ys = DataGen.RandomNormal(rand, pointCount, mean: 20, stdDev: 2);\n\ndouble[] yErr = DataGen.RandomNormal(rand, pointCount).Select(e =\u003E Math.Abs(e)).ToArray();\n\nplt.AddScatter(xs, ys, System.Drawing.Color.Blue, lineStyle: LineStyle.Dot);\nplt.AddErrorBars(xs, ys, null, yErr, System.Drawing.Color.Blue);\n\nplt.SaveFig(\u0022errorBar_oneDimension.png\u0022);"
    },
    {
      "id": "errorBar_customization",
      "category": "Plottable: Error Bar",
      "title": "Customization",
      "description": "You can customize the colour, cap size, and line width of the error bars.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nRandom rand = new Random(0);\nint pointCount = 20;\n\ndouble[] xs = DataGen.Consecutive(pointCount);\ndouble[] ys = DataGen.RandomNormal(rand, pointCount, mean: 20, stdDev: 2);\n\ndouble[] yErr = DataGen.RandomNormal(rand, pointCount).Select(e =\u003E Math.Abs(e)).ToArray();\n\nplt.AddScatter(xs, ys, System.Drawing.Color.Blue, lineStyle: LineStyle.Dot);\n\nvar errorBars = plt.AddErrorBars(xs, ys, null, yErr);\nerrorBars.CapSize = 8;\nerrorBars.Color = System.Drawing.Color.Green;\nerrorBars.LineWidth = 3;\n\nplt.SaveFig(\u0022errorBar_customization.png\u0022);"
    },
    {
      "id": "errorBar_marker",
      "category": "Plottable: Error Bar",
      "title": "Error Bar Marker",
      "description": "An optional marker can be drawn at the center X/Y position for each error bar.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nRandom rand = new Random(0);\nint pointCount = 50;\ndouble[] xs = DataGen.Consecutive(pointCount);\ndouble[] ys = DataGen.NoisyBellCurve(rand, pointCount);\ndouble[] yErr = DataGen.Random(rand, pointCount, multiplier: .2, offset: .05);\n\nplt.AddErrorBars(xs, ys, null, yErr, markerSize: 5);\n\nplt.SaveFig(\u0022errorBar_marker.png\u0022);"
    },
    {
      "id": "fill_curve",
      "category": "Plottable: Fill",
      "title": "Fill Under Curve",
      "description": "Fill methods help to create semitransparent polygons to fill the area under a curve. This can be used to give the appearance of shading under a scatter plot, even though the plottable created here is a polygon with optional edge color and fill color.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// create sample data\ndouble[] xs = DataGen.Range(0, 10, .1, true);\ndouble[] ys1 = DataGen.Sin(xs);\ndouble[] ys2 = DataGen.Cos(xs);\n\n// add filled polygons\nplt.AddFill(xs, ys1);\nplt.AddFill(xs, ys2, baseline: -.25);\n\n// tighten the axis limits so we don\u0027t see lines on the edges\nplt.SetAxisLimits(xMin: 0, xMax: 10);\n\nplt.SaveFig(\u0022fill_curve.png\u0022);"
    },
    {
      "id": "fill_aboveBelow",
      "category": "Plottable: Fill",
      "title": "Fill Above and Below",
      "description": "Sometimes you want to share the area under a curve, but change its color depending on which side of the baseline value it is. There\u0027s a helper method to make this easier.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// create sample data\nRandom rand = new Random(3);\ndouble[] xs = DataGen.Consecutive(201);\ndouble[] ys = DataGen.RandomWalk(rand, xs.Length);\n\n// add filled polygons\nplt.AddFillAboveAndBelow(xs, ys);\n\n// tighten the axis limits so we don\u0027t see lines on the edges\nplt.SetAxisLimits(xMin: 0, xMax: 200);\n\nplt.SaveFig(\u0022fill_aboveBelow.png\u0022);"
    },
    {
      "id": "fill_between",
      "category": "Plottable: Fill",
      "title": "Fill Between Curves",
      "description": "Given two curves, a polygon can be created to give the appearance of shading between them. Here we will display two scatter plots, then create a polygon to fill the region between them.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// create sample data\ndouble[] xs = DataGen.Range(0, 10, .1, true);\ndouble[] ys1 = DataGen.Sin(xs);\ndouble[] ys2 = DataGen.Cos(xs);\n\n// add a polygon to fill the region between the two curves\nplt.AddFill(xs, ys1, xs, ys2);\n\n// add two scatter plots the traditional way\nplt.AddScatter(xs, ys1, color: Color.Black);\nplt.AddScatter(xs, ys2, color: Color.Black);\n\n// tighten the axis limits so we don\u0027t see lines on the edges\nplt.SetAxisLimits(xMin: 0, xMax: 10);\n\nplt.SaveFig(\u0022fill_between.png\u0022);"
    },
    {
      "id": "fill_hatched",
      "category": "Plottable: Fill",
      "title": "Hatched Fill",
      "description": "Hatched Fills are useful for when there are overlapping fills, such as this diagram depicting the ranges of possible producer surpluses under a price floor.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble SupplyFunction(double q) =\u003E 5 * q \u002B 1;\ndouble DemandFunction(double q) =\u003E -3 * q \u002B 17;\n\nconst double priceFloor = 12.5;\ndouble[] xs = DataGen.Consecutive(5);\ndouble[] supply = xs.Select(SupplyFunction).ToArray();\ndouble[] demand = xs.Select(DemandFunction).ToArray();\n\nplt.AddScatter(xs, supply, markerShape: MarkerShape.none, label: \u0022Supply\u0022);\nplt.AddScatter(xs, demand, markerShape: MarkerShape.none, label: \u0022Demand\u0022);\nplt.AddHorizontalLine(priceFloor, label: \u0022Price Floor\u0022);\n\ndouble[] maxProducerSurplusBounds = new double[] { 0, 1.5 };\nvar maxProducerSurplus = plt.AddFill(maxProducerSurplusBounds, maxProducerSurplusBounds.Select(SupplyFunction).ToArray(), maxProducerSurplusBounds, Enumerable.Repeat(priceFloor, 2).ToArray());\nmaxProducerSurplus.LineWidth = 0;\nmaxProducerSurplus.FillColor = Color.LawnGreen;\nmaxProducerSurplus.HatchColor = Color.Transparent;\nmaxProducerSurplus.HatchStyle = Drawing.HatchStyle.StripedWideDownwardDiagonal;\nmaxProducerSurplus.Label = \u0022Maximum Possible Producer Surplus\u0022;\n\ndouble[] minProducerSurplusBounds = new double[] { 1.2, 2.3 };\nvar minProducerSurplus = plt.AddFill(minProducerSurplusBounds, minProducerSurplusBounds.Select(SupplyFunction).ToArray(), minProducerSurplusBounds, Enumerable.Repeat(priceFloor, 2).ToArray());\nminProducerSurplus.LineWidth = 0;\nminProducerSurplus.FillColor = Color.Transparent;\nminProducerSurplus.HatchColor = Color.Red;\nminProducerSurplus.HatchStyle = Drawing.HatchStyle.StripedWideDownwardDiagonal;\nminProducerSurplus.Label = \u0022Minimum Possible Producer Surplus\u0022;\n\nplt.Legend();\n\nplt.SaveFig(\u0022fill_hatched.png\u0022);"
    },
    {
      "id": "finance_quickstart",
      "category": "Plottable: Finance",
      "title": "Candlestick Chart",
      "description": "ScottPlot can draw some financial indicators on plots in X/Y space, but users looking to develop robust financial charts should probably look at other libraries designed specifically for financial charting. The biggest limitations are (1) lack of mouse interaction and (2) the horizontal axis is strictly numeric Cartesian space and is not ideal for plotting dates. That said, some financial charting is possible with ScottPlot, and this cookbook demonstrates common use cases.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// OHLCs are open, high, low, and closing prices for a time range.\nOHLC[] prices = DataGen.RandomStockPrices(null, 60);\nplt.AddCandlesticks(prices);\n\nplt.SaveFig(\u0022finance_quickstart.png\u0022);"
    },
    {
      "id": "finance_ohlc",
      "category": "Plottable: Finance",
      "title": "OHLC Chart",
      "description": "OHLC charts are an alternative to candlestick charts. They show high and low prices as a vertical line, and indicate open and close prices with little ticks to the left and to the right.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nOHLC[] prices = DataGen.RandomStockPrices(null, 60);\nplt.AddOHLCs(prices);\n\nplt.SaveFig(\u0022finance_ohlc.png\u0022);"
    },
    {
      "id": "finance_dateTimeAxis",
      "category": "Plottable: Finance",
      "title": "Using a DateTime Axis",
      "description": "You probably never want to do this... but OHLCs have an X value you can customize to be a DateTime (converted to a double using DateTime.ToOATime()). The advantage is that you can use the native DateTime axis support on the horizontal axis. The disadvantage is that gaps in time appear as gaps in the candlesticks. Weekends without trading will appear as gaps. The alternative to this method is to plot a series of OHLCs using sequential numbers, then manually define the axis tick labels.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nOHLC[] prices = DataGen.RandomStockPrices(null, 60, TimeSpan.FromDays(1));\n\n// add the OHLCs to the plot and the horizontal axis to display DateTime tick labels\nplt.AddCandlesticks(prices);\nplt.XAxis.DateTimeFormat(true);\n\nplt.SaveFig(\u0022finance_dateTimeAxis.png\u0022);"
    },
    {
      "id": "finance_tickLabels",
      "category": "Plottable: Finance",
      "title": "Candlesticks with Custom Tick Labels",
      "description": "A better way to represent time on the horizontal axis is to use traditional Cartesian coordinates so each candlestick is placed at X positions (0, 1, 2, etc.), then manually define the locations and label text of important positions on the plot. This is clunky, but possible. This inelegance is why financial charting is probably best done with real financial charting libraries, not a scientific charting library like ScottPlot...",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nOHLC[] prices = DataGen.RandomStockPrices(null, 30);\nplt.AddCandlesticks(prices);\n\n// manually indicate where axis ticks should be and what their labels should say\ndouble[] tickPositions = { 0, 6, 13, 20, 27 };\nstring[] tickLabels = { \u0022Sep 23\u0022, \u0022Sep 30\u0022, \u0022Oct 7\u0022, \u0022Oct 14\u0022, \u0022Oct 21\u0022 };\nplt.XTicks(tickPositions, tickLabels);\n\nplt.SaveFig(\u0022finance_tickLabels.png\u0022);"
    },
    {
      "id": "finance_sma",
      "category": "Plottable: Finance",
      "title": "Simple Moving Average (SMA)",
      "description": "A simple moving average (SMA) technical indicator can be calculated and drawn as a scatter plot.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nOHLC[] ohlcs = DataGen.RandomStockPrices(null, 75);\nvar candlePlot = plt.AddCandlesticks(ohlcs);\n\nvar sma8 = candlePlot.GetSMA(8);\nplt.AddScatterLines(sma8.xs, sma8.ys, Color.Blue, 2);\n\nvar sma20 = candlePlot.GetSMA(20);\nplt.AddScatterLines(sma20.xs, sma20.ys, Color.Navy, 2);\n\nplt.SaveFig(\u0022finance_sma.png\u0022);"
    },
    {
      "id": "finance_bollinger",
      "category": "Plottable: Finance",
      "title": "Bollinger Bands",
      "description": "Bollinger bands are a common technical indicator that show the average \u002B/- two times the standard deviation of a given time range preceeding it.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nOHLC[] ohlcs = DataGen.RandomStockPrices(null, 100);\nvar candlePlot = plt.AddCandlesticks(ohlcs);\n\nvar bol = candlePlot.GetBollingerBands(20);\nplt.AddScatterLines(bol.xs, bol.sma, Color.Blue);\nplt.AddScatterLines(bol.xs, bol.lower, Color.Blue, lineStyle: LineStyle.Dash);\nplt.AddScatterLines(bol.xs, bol.upper, Color.Blue, lineStyle: LineStyle.Dash);\n\nplt.SaveFig(\u0022finance_bollinger.png\u0022);"
    },
    {
      "id": "finance_right",
      "category": "Plottable: Finance",
      "title": "Price on Right",
      "description": "Newer data appears on the ride side of the chart so financial charts are often displayed with the vertical axis label on the right side as well. This is possible by disabling the left vertical axis (YAxis) and enabling the right one (YAxis2). The left and right Y axes are index 0 and 1 (respectively), and the plottable has to be update to indicate which axis index it should render on.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nOHLC[] prices = DataGen.RandomStockPrices(null, 30, TimeSpan.FromMinutes(5));\nvar candlePlot = plt.AddCandlesticks(prices);\ncandlePlot.YAxisIndex = 1;\nplt.XAxis.DateTimeFormat(true);\n\nplt.YAxis.Ticks(false);\nplt.YAxis2.Ticks(true);\nplt.YAxis2.Label(\u0022Price (USD)\u0022);\n\nplt.SaveFig(\u0022finance_right.png\u0022);"
    },
    {
      "id": "finance_wick",
      "category": "Plottable: Finance",
      "title": "Custom Wick Color",
      "description": "By default candle wicks are the same color as their bodies, but this can be customized.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nOHLC[] prices = DataGen.RandomStockPrices(null, 30, TimeSpan.FromMinutes(5));\nvar fp = plt.AddCandlesticks(prices);\nfp.WickColor = Color.Black;\n\nplt.SaveFig(\u0022finance_wick.png\u0022);"
    },
    {
      "id": "finance_color",
      "category": "Plottable: Finance",
      "title": "Custom Colors",
      "description": "Candles that close below their open price are colored differently from candles which close at or above it. These colors can be customized. Combine this styling with a custom wick color (which also controls the candle border) to create a different visual style.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nOHLC[] prices = DataGen.RandomStockPrices(null, 30, TimeSpan.FromMinutes(5));\nvar fp = plt.AddCandlesticks(prices);\nfp.ColorDown = Color.Black;\nfp.ColorUp = Color.White;\nfp.WickColor = Color.Black;\n\nplt.SaveFig(\u0022finance_color.png\u0022);"
    },
    {
      "id": "finance_dark",
      "category": "Plottable: Finance",
      "title": "Dark Mode",
      "description": "A dark mode finance plot can be realized by customizing color options of the candles and figure. Colors in this example were chosen to mimic TC2000.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// add some random candles\nOHLC[] prices = DataGen.RandomStockPrices(null, 100, TimeSpan.FromMinutes(5));\ndouble[] xs = prices.Select(x =\u003E x.DateTime.ToOADate()).ToArray();\nvar candlePlot = plt.AddCandlesticks(prices);\ncandlePlot.YAxisIndex = 1;\n\nplt.XAxis.DateTimeFormat(true);\n\n// add SMA indicators for 8 and 20 days\nvar sma8 = candlePlot.GetSMA(8);\nvar sma20 = candlePlot.GetSMA(20);\nvar sma8plot = plt.AddScatterLines(sma8.xs, sma8.ys, Color.Cyan, 2, label: \u00228 day SMA\u0022);\nvar sma20plot = plt.AddScatterLines(sma20.xs, sma20.ys, Color.Yellow, 2, label: \u002220 day SMA\u0022);\nsma8plot.YAxisIndex = 1;\nsma20plot.YAxisIndex = 1;\n\n// customize candle styling\ncandlePlot.ColorDown = ColorTranslator.FromHtml(\u0022#00FF00\u0022);\ncandlePlot.ColorUp = ColorTranslator.FromHtml(\u0022#FF0000\u0022);\n\n// customize figure styling\nplt.Layout(padding: 12);\nplt.Style(figureBackground: Color.Black, dataBackground: Color.Black);\nplt.Frameless();\nplt.XAxis.TickLabelStyle(color: Color.White);\nplt.XAxis.TickMarkColor(ColorTranslator.FromHtml(\u0022#333333\u0022));\nplt.XAxis.MajorGrid(color: ColorTranslator.FromHtml(\u0022#333333\u0022));\n\n// hide the left axis and show a right axis\nplt.YAxis.Ticks(false);\nplt.YAxis.Grid(false);\nplt.YAxis2.Ticks(true);\nplt.YAxis2.Grid(true);\nplt.YAxis2.TickLabelStyle(color: ColorTranslator.FromHtml(\u0022#00FF00\u0022));\nplt.YAxis2.TickMarkColor(ColorTranslator.FromHtml(\u0022#333333\u0022));\nplt.YAxis2.MajorGrid(color: ColorTranslator.FromHtml(\u0022#333333\u0022));\n\n// customize the legend style\nvar legend = plt.Legend();\nlegend.FillColor = Color.Transparent;\nlegend.OutlineColor = Color.Transparent;\nlegend.Font.Color = Color.White;\nlegend.Font.Bold = true;\n\nplt.SaveFig(\u0022finance_dark.png\u0022);"
    },
    {
      "id": "function_quickstart",
      "category": "Plottable: Function",
      "title": "Function",
      "description": "Function plots are defined by a function (not X/Y data points) so the curve is continuous and can be zoomed in and out infinitely",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// Functions are defined as delegates with an input and output\nvar func1 = new Func\u003Cdouble, double?\u003E((x) =\u003E Math.Sin(x) * Math.Sin(x / 2));\nvar func2 = new Func\u003Cdouble, double?\u003E((x) =\u003E Math.Sin(x) * Math.Sin(x / 3));\nvar func3 = new Func\u003Cdouble, double?\u003E((x) =\u003E Math.Cos(x) * Math.Sin(x / 5));\n\n// Add functions to the plot\nplt.AddFunction(func1, lineWidth: 2);\nplt.AddFunction(func2, lineWidth: 2, lineStyle: LineStyle.Dot);\nplt.AddFunction(func3, lineWidth: 2, lineStyle: LineStyle.Dash);\n\nplt.SaveFig(\u0022function_quickstart.png\u0022);"
    },
    {
      "id": "heatmap_quickstart",
      "category": "Plottable: Heatmap",
      "title": "Heatmap Quickstart",
      "description": "Heatmaps display a 2D array using a colormap.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[,] data2D = { { 1, 2, 3 },\n         { 4, 5, 6 } };\n\nplt.SaveFig(\u0022heatmap_quickstart.png\u0022);"
    },
    {
      "id": "heatmap_margins",
      "category": "Plottable: Heatmap",
      "title": "Heatmap with Tight Margins",
      "description": "The heatmap can fit the plot area exactly if margins are set to zero and the square axis lock is disabled.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[,] data2D = { { 1, 2, 3 },\n         { 4, 5, 6 } };\n\nplt.AddHeatmap(data2D, lockScales: false);\nplt.Margins(0, 0);\n\nplt.SaveFig(\u0022heatmap_margins.png\u0022);"
    },
    {
      "id": "heatmap_colorbar",
      "category": "Plottable: Heatmap",
      "title": "Heatmap with Colorbar",
      "description": "Colorbars are often added when heatmaps are used.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[,] data2D = { { 1, 2, 3 },\n         { 4, 5, 6 } };\n\nvar hm = plt.AddHeatmap(data2D, lockScales: false);\nvar cb = plt.AddColorbar(hm);\nplt.Margins(0, 0);\n\nplt.SaveFig(\u0022heatmap_colorbar.png\u0022);"
    },
    {
      "id": "heatmap_smooth",
      "category": "Plottable: Heatmap",
      "title": "Smooth Heatmap",
      "description": "Heatmaps display values as rectangles with sharp borders by default. Enabling the Smooth feature uses bicubic interpolation to display the heatmap as a smooth gradient between values.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nvar rand = new Random(0);\ndouble[,] data2D = DataGen.Random2D(rand, 5, 4);\n\nvar hm = plt.AddHeatmap(data2D, lockScales: false);\nhm.Smooth = true;\n\nplt.SaveFig(\u0022heatmap_smooth.png\u0022);"
    },
    {
      "id": "heatmap_image",
      "category": "Plottable: Heatmap",
      "title": "Heatmap Image",
      "description": "Image data can be plotted using the heatmap plot type.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[,] imageData = DataGen.SampleImageData();\nplt.AddHeatmap(imageData);\n\nplt.SaveFig(\u0022heatmap_image.png\u0022);"
    },
    {
      "id": "heatmap_2dWaveform",
      "category": "Plottable: Heatmap",
      "title": "2D Waveform",
      "description": "This example demonstrates a heatmap with 1000 tiles",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nint width = 100;\nint height = 100;\n\ndouble[,] intensities = new double[width, height];\n\nfor (int x = 0; x \u003C width; x\u002B\u002B)\n    for (int y = 0; y \u003C height; y\u002B\u002B)\n        intensities[x, y] = (Math.Sin(x * .2) \u002B Math.Cos(y * .2)) * 100;\n\nvar hm = plt.AddHeatmap(intensities);\nvar cb = plt.AddColorbar(hm);\n\nplt.SaveFig(\u0022heatmap_2dWaveform.png\u0022);"
    },
    {
      "id": "heatmap_colormap",
      "category": "Plottable: Heatmap",
      "title": "Colormap",
      "description": "Viridis is the default colormap, but several alternatives are available.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[,] intensities = new double[100, 100];\nfor (int x = 0; x \u003C 100; x\u002B\u002B)\n    for (int y = 0; y \u003C 100; y\u002B\u002B)\n        intensities[x, y] = (Math.Sin(x * .2) \u002B Math.Cos(y * .2)) * 100;\n\nvar hm = plt.AddHeatmap(intensities, Drawing.Colormap.Turbo);\nvar cb = plt.AddColorbar(hm);\n\nplt.SaveFig(\u0022heatmap_colormap.png\u0022);"
    },
    {
      "id": "styled_heatmap_colormap",
      "category": "Plottable: Heatmap",
      "title": "Styled Colormap",
      "description": "Viridis is the default colormap, but several alternatives are available.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[,] intensities = new double[100, 100];\nfor (int x = 0; x \u003C 100; x\u002B\u002B)\n    for (int y = 0; y \u003C 100; y\u002B\u002B)\n        intensities[x, y] = (Math.Sin(x * .2) \u002B Math.Cos(y * .2)) * 100;\n\nvar hm = plt.AddHeatmap(intensities, Drawing.Colormap.Turbo);\nvar cb = plt.AddColorbar(hm);\n\nplt.Style(Style.Black);\n\nplt.SaveFig(\u0022styled_heatmap_colormap.png\u0022);"
    },
    {
      "id": "heatmap_limitScale",
      "category": "Plottable: Heatmap",
      "title": "Scale Limits",
      "description": "Heatmap colormap scale can use a defined min/max value.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[,] intensities = new double[100, 100];\nfor (int x = 0; x \u003C 100; x\u002B\u002B)\n    for (int y = 0; y \u003C 100; y\u002B\u002B)\n        intensities[x, y] = (Math.Sin(x * .2) \u002B Math.Cos(y * .2)) * 100;\n\n// scale the colors between 0 and 200\nvar hm = plt.AddHeatmap(intensities);\nhm.Update(intensities, min: 0, max: 200);\n\n// add a colorbar with custom ticks\nvar cb = plt.AddColorbar(hm);\ndouble[] tickPositions = ScottPlot.DataGen.Range(0, 200, 25, true);\nstring[] tickLabels = tickPositions.Select(x =\u003E x.ToString()).ToArray();\ncb.SetTicks(tickPositions, tickLabels, min: 0, max: 200);\n\nplt.SaveFig(\u0022heatmap_limitScale.png\u0022);"
    },
    {
      "id": "heatmap_clip",
      "category": "Plottable: Heatmap",
      "title": "Color Clipping",
      "description": "The value range displayed by the colormap can restricted to a narrow subset of the full data range. Tick labels at the edges of the colorbar can be made to show inequality symbols to indicate the range of data is being clipped when translating values to colors.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[,] imageData = DataGen.SampleImageData();\nvar heatmap = plt.AddHeatmap(imageData);\nheatmap.Update(imageData, min: 75, max: 125);\n\nvar cb = plt.AddColorbar(heatmap);\n\n// configure the colorbar to display inequality operators at the edges\ncb.MaxIsClipped = true;\ncb.MinIsClipped = true;\n\nplt.SaveFig(\u0022heatmap_clip.png\u0022);"
    },
    {
      "id": "heatmap_density",
      "category": "Plottable: Heatmap",
      "title": "Interpolation by Density",
      "description": "Heatmaps can be created from random 2D data points using the count within a square of fixed size.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nRandom rand = new Random(0);\nint[] xs = DataGen.RandomNormal(rand, 10000, 25, 10).Select(x =\u003E (int)x).ToArray();\nint[] ys = DataGen.RandomNormal(rand, 10000, 25, 10).Select(y =\u003E (int)y).ToArray();\n\ndouble[,] intensities = Tools.XYToIntensities(mode: IntensityMode.Density,\n    xs: xs, ys: ys, width: 50, height: 50, sampleWidth: 4);\n\nvar hm = plt.AddHeatmap(intensities);\nvar cb = plt.AddColorbar(hm);\n\nplt.SaveFig(\u0022heatmap_density.png\u0022);"
    },
    {
      "id": "heatmap_gaussian",
      "category": "Plottable: Heatmap",
      "title": "Gaussian Interpolation",
      "description": "Heatmaps can be created from 2D data points using bilinear interpolation with Gaussian weighting. This option results in a heatmap with a standard deviation of 4.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nRandom rand = new Random(0);\nint[] xs = DataGen.RandomNormal(rand, 10000, 25, 10).Select(x =\u003E (int)x).ToArray();\nint[] ys = DataGen.RandomNormal(rand, 10000, 25, 10).Select(y =\u003E (int)y).ToArray();\n\ndouble[,] intensities = Tools.XYToIntensities(mode: IntensityMode.Gaussian,\n    xs: xs, ys: ys, width: 50, height: 50, sampleWidth: 4);\n\nvar hm = plt.AddHeatmap(intensities);\nvar cb = plt.AddColorbar(hm);\n\nplt.SaveFig(\u0022heatmap_gaussian.png\u0022);"
    },
    {
      "id": "heatmap_dimensions",
      "category": "Plottable: Heatmap",
      "title": "Custom Dimensions",
      "description": "By default heatmaps start at the origin and each rectangle (cell) is 1 unit in size, but heatmap offset and cell size can be customized.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[,] data2D = { { 1, 2, 3 },\n         { 4, 5, 6 } };\n\nvar hm = plt.AddHeatmap(data2D, lockScales: false);\nhm.OffsetX = 10;\nhm.OffsetY = 20;\nhm.CellWidth = 5;\nhm.CellHeight = 10;\n\nplt.SaveFig(\u0022heatmap_dimensions.png\u0022);"
    },
    {
      "id": "heatmap_transparent",
      "category": "Plottable: Heatmap",
      "title": "Heatmap with Empty Squares",
      "description": "You can use a 2D array of nullable doubles to indicate some squares do not contain data. This allows the user to display heatmaps with transparency and implement non-rectangular heatmaps.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble?[,] intensities = {\n    { 1, 7, 4, null },\n    { 9, null, 2, 4 },\n    { 1, 4, null, 8 },\n    { null, 2, 4, null }\n};\n\nvar hmc = plt.AddHeatmap(intensities);\nvar cb = plt.AddColorbar(hmc);\n\nplt.SaveFig(\u0022heatmap_transparent.png\u0022);"
    },
    {
      "id": "heatmap_placement",
      "category": "Plottable: Heatmap",
      "title": "Size and Placement",
      "description": "Edges of the heatmap can be defined as an alternative to defining offset and cell size,",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[,] imageData = DataGen.SampleImageData();\nvar hm = plt.AddHeatmap(imageData, lockScales: false);\n\nhm.XMin = -100;\nhm.XMax = 100;\nhm.YMin = -10;\nhm.YMax = 10;\n\nplt.SaveFig(\u0022heatmap_placement.png\u0022);"
    },
    {
      "id": "image_quickstart",
      "category": "Plottable: Image",
      "title": "Image Quickstart",
      "description": "The Image plottable places a Bitmap at a location in X/Y space.The image\u0027s position will move in space as the axes move, but the size of the bitmap will always be the same (matched to the display resolution). ",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// display some sample data\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\n// create the bitmap we want to display\nBitmap monaLisa = DataGen.SampleImage();\n\n// create the image plottable and add it to the plot\nvar imagePlot = new ScottPlot.Plottable.Image() { Bitmap = monaLisa, X = 10, Y = .5 };\n\nplt.Add(imagePlot);\n\nplt.SaveFig(\u0022image_quickstart.png\u0022);"
    },
    {
      "id": "image_alignment",
      "category": "Plottable: Image",
      "title": "Image Alignment",
      "description": "By default the X/Y coordinates define the upper left position of the image, but alignment can be customized.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// display some sample data\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\n// display an image with 3 different alignments\nBitmap monaLisa = DataGen.SampleImage();\nvar ip1 = new ScottPlot.Plottable.Image() { Bitmap = monaLisa, X = 10 };\nvar ip2 = new ScottPlot.Plottable.Image() { Bitmap = monaLisa, X = 25, Alignment = Alignment.MiddleCenter };\nvar ip3 = new ScottPlot.Plottable.Image() { Bitmap = monaLisa, X = 40, Alignment = Alignment.LowerRight };\n\nplt.Add(ip1);\nplt.Add(ip2);\nplt.Add(ip3);\n\nplt.AddPoint(ip1.X, ip1.Y, Color.Magenta, size: 20);\nplt.AddPoint(ip2.X, ip2.Y, Color.Magenta, size: 20);\nplt.AddPoint(ip3.X, ip3.Y, Color.Magenta, size: 20);\n\nplt.SaveFig(\u0022image_alignment.png\u0022);"
    },
    {
      "id": "image_rotation",
      "category": "Plottable: Image",
      "title": "Image Rotation",
      "description": "Images can be rotated, but rotation is always relative to the upper left corner.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// display some sample data\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\n// place a rotated image on the plot\nBitmap monaLisa = DataGen.SampleImage();\nvar ip1 = new ScottPlot.Plottable.Image() { Bitmap = monaLisa, X = 10, Y = .5, Rotation = 30 };\nplt.Add(ip1);\nplt.AddPoint(ip1.X, ip1.Y, color: Color.Magenta, size: 20);\n\nplt.SaveFig(\u0022image_rotation.png\u0022);"
    },
    {
      "id": "image_border",
      "category": "Plottable: Image",
      "title": "Image Border",
      "description": "The borders of images can be customized.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// display some sample data\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\n// place an image on the plot\nplt.Add(new ScottPlot.Plottable.Image()\n{\n    Bitmap = DataGen.SampleImage(),\n    X = 10,\n    Y = .5,\n    Rotation = 30,\n    BorderColor = Color.Magenta,\n    BorderSize = 5,\n});\n\nplt.SaveFig(\u0022image_border.png\u0022);"
    },
    {
      "id": "marker_quickstart",
      "category": "Plottable: Marker",
      "title": "Marker",
      "description": "You can place individual markers anywhere on the plot. ",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nvar colormap = ScottPlot.Drawing.Colormap.Turbo;\nRandom rand = new(0);\nfor (int i = 0; i \u003C 100; i\u002B\u002B)\n{\n    plt.AddMarker(\n        x: rand.NextDouble(),\n        y: rand.NextDouble(),\n        size: 5 \u002B rand.NextDouble() * 20,\n        shape: Marker.Random(rand),\n        color: colormap.RandomColor(rand));\n}\n\nplt.SaveFig(\u0022marker_quickstart.png\u0022);"
    },
    {
      "id": "marker_draggable",
      "category": "Plottable: Marker",
      "title": "Draggable Marker",
      "description": "A special type of marker exists which allows dragging with the mouse.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.AddSignal(ScottPlot.DataGen.Sin(51));\nplt.AddSignal(ScottPlot.DataGen.Cos(51));\n\nvar myDraggableMarker = new ScottPlot.Plottable.DraggableMarkerPlot()\n{\n    X = 25,\n    Y = .57,\n    Color = Color.Magenta,\n    MarkerShape = MarkerShape.filledDiamond,\n    MarkerSize = 15,\n    Text = \u0022drag the point!\u0022,\n};\n\nmyDraggableMarker.TextFont.Size = 16;\n\nplt.Add(myDraggableMarker);\n\nplt.SaveFig(\u0022marker_draggable.png\u0022);"
    },
    {
      "id": "marker_draggableinvector",
      "category": "Plottable: Marker",
      "title": "Draggable Marker Snap",
      "description": "This is a type of marker which can be dragged with the mouse, but is restricted to to X/Y positions defined by two arrays.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// create random data and display it with a scatter plot\ndouble[] xs = DataGen.Consecutive(50);\ndouble[] ys = DataGen.Random(new Random(0), 50);\nplt.AddScatter(xs, ys, label: \u0022data\u0022);\n\n// add a draggable marker that \u0022snaps\u0022 to data values in that scatter plot\nvar dmpv = new ScottPlot.Plottable.DraggableMarkerPlotInVector()\n{\n    Xs = xs,\n    Ys = ys,\n    DragEnabled = true,\n    IsVisible = true,\n    MarkerSize = 15,\n    MarkerShape = MarkerShape.filledDiamond,\n    MarkerColor = Color.Magenta,\n    Label = \u0022marker\u0022,\n};\nplt.Add(dmpv);\n\nplt.Legend();\n\nplt.SaveFig(\u0022marker_draggableinvector.png\u0022);"
    },
    {
      "id": "marker_labeled",
      "category": "Plottable: Marker",
      "title": "Labeled Marker",
      "description": "Markers have an optional text label.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.AddSignal(DataGen.Sin(51));\n\nvar marker = plt.AddMarker(35, 0.6);\nmarker.Text = \u0022Interesting Point\u0022;\nmarker.TextFont.Color = Color.Magenta;\nmarker.TextFont.Alignment = Alignment.UpperCenter;\nmarker.TextFont.Size = 28;\n\nplt.SaveFig(\u0022marker_labeled.png\u0022);"
    },
    {
      "id": "marker_linewidth",
      "category": "Plottable: Marker",
      "title": "Marker Line Width",
      "description": "Markers have options that can be customized, such as line width.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] ys1 = DataGen.Sin(30);\nvar cmap1 = ScottPlot.Drawing.Colormap.Viridis;\n\ndouble[] ys2 = DataGen.Cos(30);\nvar cmap2 = ScottPlot.Drawing.Colormap.Turbo;\n\nfor (int i = 0; i \u003C ys1.Length; i\u002B\u002B)\n{\n    double frac = i / (ys1.Length - 1f);\n\n    var circle = plt.AddMarker(i, ys1[i]);\n    circle.MarkerShape = MarkerShape.openCircle;\n    circle.MarkerSize = i \u002B 5;\n    circle.MarkerLineWidth = 1 \u002B i / 2;\n    circle.MarkerColor = cmap1.GetColor(1 - frac, .8);\n\n    var triangle = plt.AddMarker(i, ys2[i]);\n    triangle.MarkerShape = MarkerShape.openTriangleUp;\n    triangle.MarkerSize = i \u002B 5;\n    triangle.MarkerLineWidth = 1 \u002B i / 4;\n    triangle.MarkerColor = cmap2.GetColor(frac, .8);\n}\n\nplt.Margins(.2, .2);\n\nplt.SaveFig(\u0022marker_linewidth.png\u0022);"
    },
    {
      "id": "pie_quickstart",
      "category": "Plottable: Pie",
      "title": "Pie Chart",
      "description": "A pie chart illustrates numerical proportions as slices of a circle.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] values = { 778, 283, 184, 76, 43 };\nplt.AddPie(values);\n\nplt.SaveFig(\u0022pie_quickstart.png\u0022);"
    },
    {
      "id": "pie_exploded",
      "category": "Plottable: Pie",
      "title": "Exploded Pie Chart",
      "description": "Exploded pie charts have a bit of space between their slices.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] values = { 778, 283, 184, 76, 43 };\nvar pie = plt.AddPie(values);\npie.Explode = true;\n\nplt.SaveFig(\u0022pie_exploded.png\u0022);"
    },
    {
      "id": "pie_donut",
      "category": "Plottable: Pie",
      "title": "Donut Chart",
      "description": "Donut plots are pie charts with a hollow center.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] values = { 778, 283, 184, 76, 43 };\nvar pie = plt.AddPie(values);\npie.Explode = true;\npie.DonutSize = .6;\n\nplt.SaveFig(\u0022pie_donut.png\u0022);"
    },
    {
      "id": "pie_donutText",
      "category": "Plottable: Pie",
      "title": "Donut with Text",
      "description": "Custom text can be displayed in the center of a donut chart. Notice too how the colors of each slice are customized in this example.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] values = { 779, 586 };\nstring centerText = $\u0022{values[0] / values.Sum() * 100:00.0}%\u0022;\nColor color1 = Color.FromArgb(255, 0, 150, 200);\nColor color2 = Color.FromArgb(100, 0, 150, 200);\n\nvar pie = plt.AddPie(values);\npie.DonutSize = .6;\npie.DonutLabel = centerText;\npie.CenterFont.Color = color1;\npie.OutlineSize = 2;\npie.SliceFillColors = new Color[] { color1, color2 };\n\nplt.SaveFig(\u0022pie_donutText.png\u0022);"
    },
    {
      "id": "pie_showValues",
      "category": "Plottable: Pie",
      "title": "Slice Values",
      "description": "The value of each slice can be displayed at its center.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] values = { 778, 43, 283, 76, 184 };\nvar pie = plt.AddPie(values);\npie.ShowValues = true;\n\nplt.SaveFig(\u0022pie_showValues.png\u0022);"
    },
    {
      "id": "pie_showPercentage",
      "category": "Plottable: Pie",
      "title": "Slice Percentages",
      "description": "The percentage of each slice can be displayed at its center.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] values = { 778, 43, 283, 76, 184 };\nvar pie = plt.AddPie(values);\npie.ShowPercentages = true;\n\nplt.SaveFig(\u0022pie_showPercentage.png\u0022);"
    },
    {
      "id": "pie_customColors",
      "category": "Plottable: Pie",
      "title": "Customize Pie Colors",
      "description": "Colors for pie slices and labels can be customized.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] values = { 778, 43, 283, 76, 184 };\nstring[] labels = { \u0022C#\u0022, \u0022JAVA\u0022, \u0022Python\u0022, \u0022F#\u0022, \u0022PHP\u0022 };\n\n// Language colors from https://github.com/ozh/github-colors\nColor[] sliceColors =\n{\n    ColorTranslator.FromHtml(\u0022#178600\u0022),\n    ColorTranslator.FromHtml(\u0022#B07219\u0022),\n    ColorTranslator.FromHtml(\u0022#3572A5\u0022),\n    ColorTranslator.FromHtml(\u0022#B845FC\u0022),\n    ColorTranslator.FromHtml(\u0022#4F5D95\u0022),\n};\n\n// Show labels using different transparencies\nColor[] labelColors =\n    new Color[] {\n    Color.FromArgb(255, Color.White),\n    Color.FromArgb(100, Color.White),\n    Color.FromArgb(250, Color.White),\n    Color.FromArgb(150, Color.White),\n    Color.FromArgb(200, Color.White),\n};\n\nvar pie = plt.AddPie(values);\npie.SliceLabels = labels;\npie.ShowLabels = true;\npie.SliceFillColors = sliceColors;\npie.SliceLabelColors = labelColors;\n\nplt.SaveFig(\u0022pie_customColors.png\u0022);"
    },
    {
      "id": "pie_legend",
      "category": "Plottable: Pie",
      "title": "Slices in Legend",
      "description": "Slices can be labeled in the legend.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] values = { 778, 43, 283, 76, 184 };\nstring[] labels = { \u0022C#\u0022, \u0022JAVA\u0022, \u0022Python\u0022, \u0022F#\u0022, \u0022PHP\u0022 };\nvar pie = plt.AddPie(values);\npie.SliceLabels = labels;\nplt.Legend();\n\nplt.SaveFig(\u0022pie_legend.png\u0022);"
    },
    {
      "id": "pie_showEverything",
      "category": "Plottable: Pie",
      "title": "Label Everything",
      "description": "Slices can labeled with values, percentages, and lables, with a legend.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] values = { 778, 43, 283, 76, 184 };\nstring[] labels = { \u0022C#\u0022, \u0022JAVA\u0022, \u0022Python\u0022, \u0022F#\u0022, \u0022PHP\u0022 };\nvar pie = plt.AddPie(values);\npie.SliceLabels = labels;\npie.ShowPercentages = true;\npie.ShowValues = true;\npie.ShowLabels = true;\nplt.Legend();\n\nplt.SaveFig(\u0022pie_showEverything.png\u0022);"
    },
    {
      "id": "pie_customLabels",
      "category": "Plottable: Pie",
      "title": "Custom Slice Labels",
      "description": "Custom slice labels can be used to display values using custom formats",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] values = { 778, 43, 283, 76, 184 };\nstring[] labels = { \u0022C#\u0022, \u0022JAVA\u0022, \u0022Python\u0022, \u0022F#\u0022, \u0022PHP\u0022 };\n\n// modify labels to include a custom formatted value\nlabels = Enumerable.Range(0, values.Length)\n       .Select(i =\u003E $\u0022{labels[i]}\\n({values[i]})\u0022)\n       .ToArray();\n\nvar pie = plt.AddPie(values);\npie.SliceLabels = labels;\npie.ShowLabels = true;\n\nplt.SaveFig(\u0022pie_customLabels.png\u0022);"
    },
    {
      "id": "polygon_quickstart",
      "category": "Plottable: Polygon",
      "title": "Polygon Quickstart",
      "description": "Polygons are 2D shapes made from pairs of X/Y points. The last point connects back to the first point, forming a closed shape. Polygons can be optionally outlined and optionally filled. Colors with semitransparency are especially useful for polygons.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] xs1 = { 2, 8, 6, 4 };\ndouble[] ys1 = { 3, 4, 0.5, 1 };\nplt.AddPolygon(xs1, ys1);\n\ndouble[] xs2 = { 3, 2.5, 5 };\ndouble[] ys2 = { 4.5, 1.5, 2.5 };\nplt.AddPolygon(xs2, ys2, plt.GetNextColor(.5), lineWidth: 2);\n\nplt.SaveFig(\u0022polygon_quickstart.png\u0022);"
    },
    {
      "id": "polygon_filledLinePlot",
      "category": "Plottable: Polygon",
      "title": "Filled Line Plot",
      "description": "Polygons can be used to create 2D shapes resembling filled line plots. When mixed with semitransprent fills, these can be useful for displaying data.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// create sample data\ndouble[] xs = { 1, 2, 3, 4 };\ndouble[] ys1 = { 1, 3, 1, 2 };\ndouble[] ys2 = { 3, 7, 3, 1 };\ndouble[] ys3 = { 5, 2, 5, 6 };\n\n// pad data to turn a line into a shaded region\nxs = Tools.Pad(xs, cloneEdges: true);\nys1 = Tools.Pad(ys1);\nys2 = Tools.Pad(ys2);\nys3 = Tools.Pad(ys3);\n\n// plot the padded data points as polygons\nplt.AddPolygon(xs, ys3, plt.GetNextColor(.7), lineWidth: 2);\nplt.AddPolygon(xs, ys2, plt.GetNextColor(.7), lineWidth: 2);\nplt.AddPolygon(xs, ys1, plt.GetNextColor(.7), lineWidth: 2);\n\n// use tight margins so we don\u0027t see the edges of polygons\nplt.AxisAuto(0, 0);\n\nplt.SaveFig(\u0022polygon_filledLinePlot.png\u0022);"
    },
    {
      "id": "polygon_fillBetween",
      "category": "Plottable: Polygon",
      "title": "Fill Between Curves",
      "description": "A shaded area between two curves can be created by enclosing the area as a polygon. For this to work the two curves must share the same X points.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nRandom rand = new(0);\nint pointCount = 100;\ndouble[] xs = ScottPlot.DataGen.Consecutive(pointCount);\n\n// plot a shaded region\ndouble[] lower = ScottPlot.DataGen.Sin(pointCount, 5, offset: 3);\ndouble[] upper = ScottPlot.DataGen.Cos(pointCount, 5, offset: -3);\nvar poly = plt.AddFill(xs, lower, upper);\npoly.FillColor = Color.FromArgb(50, Color.Green);\n\n// plot a line within that region\ndouble[] ys = ScottPlot.DataGen.Random(rand, pointCount);\nvar sig = plt.AddSignal(ys);\nsig.Color = plt.Palette.GetColor(0);\n\nplt.Margins(0, .5);\n\nplt.SaveFig(\u0022polygon_fillBetween.png\u0022);"
    },
    {
      "id": "polygon_stackedFilledLinePlot",
      "category": "Plottable: Polygon",
      "title": "Stacked Filled Line Plot",
      "description": "A stacked filled line plot effect can be achieved by overlapping polygons.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// create sample data\ndouble[] xs = { 1, 2, 3, 4 };\ndouble[] ys1 = { 1, 3, 1, 2 };\ndouble[] ys2 = { 3, 7, 3, 1 };\ndouble[] ys3 = { 5, 2, 5, 6 };\n\n// manually stack plots\nys2 = Enumerable.Range(0, ys2.Length).Select(x =\u003E ys2[x] \u002B ys1[x]).ToArray();\nys3 = Enumerable.Range(0, ys2.Length).Select(x =\u003E ys3[x] \u002B ys2[x]).ToArray();\n\n// pad data to turn a line into a shaded region\nxs = Tools.Pad(xs, cloneEdges: true);\nys1 = Tools.Pad(ys1);\nys2 = Tools.Pad(ys2);\nys3 = Tools.Pad(ys3);\n\n// plot the padded data points as polygons\nplt.AddPolygon(xs, ys3, lineWidth: 2);\nplt.AddPolygon(xs, ys2, lineWidth: 2);\nplt.AddPolygon(xs, ys1, lineWidth: 2);\n\n// use tight margins so we don\u0027t see the edges of polygons\nplt.AxisAuto(0, 0);\n\nplt.SaveFig(\u0022polygon_stackedFilledLinePlot.png\u0022);"
    },
    {
      "id": "polygon_polygons",
      "category": "Plottable: Polygon",
      "title": "Many Polygons",
      "description": "Special rendering optimizations are available to display a large number of polygons.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// create a list of random polygons\nList\u003CList\u003C(double x, double y)\u003E\u003E polys = new List\u003CList\u003C(double x, double y)\u003E\u003E();\nint polygonCount = 5_000;\nint pointsPerPolygon = 100;\nRandom rand = new Random(0);\nfor (int i = 0; i \u003C polygonCount; i\u002B\u002B)\n{\n    // random placement\n    double polyX = rand.NextDouble() * 100;\n    double polyY = rand.NextDouble() * 100;\n\n    // points are random locations around a circle of random size\n    double polyR = rand.NextDouble();\n    double[] xs = Enumerable.Range(0, pointsPerPolygon).Select(x =\u003E polyR * Math.Cos(2.0 * Math.PI * x / pointsPerPolygon) \u002B polyX).ToArray();\n    double[] ys = Enumerable.Range(0, pointsPerPolygon).Select(x =\u003E polyR * Math.Sin(2.0 * Math.PI * x / pointsPerPolygon) \u002B polyY).ToArray();\n\n    // add this polygon to the list\n    List\u003C(double x, double y)\u003E thisPolygon = xs.Zip(ys, (xp, yp) =\u003E (xp, yp)).ToList();\n    polys.Add(thisPolygon);\n}\n\n// plot the list of polygons with one step\nplt.AddPolygons(polys, fillColor: Color.Green);\n\n// ensure X and Y pixel scales are the same (so circles aren\u0027t ovals)\nplt.AxisScaleLock(true);\n\nplt.SaveFig(\u0022polygon_polygons.png\u0022);"
    },
    {
      "id": "population_quickstart",
      "category": "Plottable: Population",
      "title": "Population Plot",
      "description": "The population plot makes it easy to display populations as bar graphs, box-and-whisker plots, scattered values, or box plots and data points side-by-side. The population plot is different than using a box plot with an error bar in that you pass your original data into the population plot and it determines the standard deviation, standard error, quartiles, mean, median, outliers, etc., and you get to determine how to display these values.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// create sample data to represent test scores\nRandom rand = new Random(0);\ndouble[] scores = DataGen.RandomNormal(rand, 35, 85, 5);\n\n// First, create a Population object from your test scores\nvar pop = new Statistics.Population(scores);\n\n// You can access population statistics as public fields\nplt.Title($\u0022Mean: {pop.mean} \u002B/- {pop.stdErr}\u0022);\n\n// You can plot a population\nplt.AddPopulation(pop);\n\n// improve the style of the plot\nplt.XAxis.Ticks(true);\nplt.XAxis.Grid(false);\n\nplt.SaveFig(\u0022population_quickstart.png\u0022);"
    },
    {
      "id": "population_multiple",
      "category": "Plottable: Population",
      "title": "Multiple Populations",
      "description": "Multiple populations can be assembled into an array and plotted as a single group.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// create sample data to represent test scores\nRandom rand = new Random(0);\ndouble[] valuesA = DataGen.RandomNormal(rand, 35, 85, 5);\ndouble[] valuesB = DataGen.RandomNormal(rand, 42, 87, 3);\ndouble[] valuesC = DataGen.RandomNormal(rand, 23, 92, 3);\n\n// create population objects for each set of data values\nvar popA = new Statistics.Population(valuesA);\nvar popB = new Statistics.Population(valuesB);\nvar popC = new Statistics.Population(valuesC);\n\n// combine several populations into an array and plot it\nvar poulations = new Statistics.Population[] { popA, popB, popC };\nstring[] populationNames = { \u0022Group A\u0022, \u0022Group B\u0022, \u0022Group C\u0022 };\nplt.AddPopulations(poulations);\n\n// improve the style of the plot\nplt.XAxis.Grid(false);\nplt.XTicks(populationNames);\n\nplt.SaveFig(\u0022population_multiple.png\u0022);"
    },
    {
      "id": "population_data_over_bar",
      "category": "Plottable: Population",
      "title": "Data points over bar",
      "description": "Alternate styling options allow data points to be displayed over the box and whisker plots.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// create sample data to represent test scores\nRandom rand = new Random(0);\ndouble[] valuesA = DataGen.RandomNormal(rand, 35, 85, 5);\ndouble[] valuesB = DataGen.RandomNormal(rand, 42, 87, 3);\ndouble[] valuesC = DataGen.RandomNormal(rand, 23, 92, 3);\n\n// create population objects for each set of data values\nvar popA = new Statistics.Population(valuesA);\nvar popB = new Statistics.Population(valuesB);\nvar popC = new Statistics.Population(valuesC);\n\n// combine several populations into an array and plot it\nvar poulations = new Statistics.Population[] { popA, popB, popC };\nstring[] populationNames = { \u0022Group A\u0022, \u0022Group B\u0022, \u0022Group C\u0022 };\n\n// customize the data display format\nvar popPlot = plt.AddPopulations(poulations);\npopPlot.DistributionCurve = false;\npopPlot.DataFormat = ScottPlot.Plottable.PopulationPlot.DisplayItems.ScatterOnBox;\npopPlot.DataBoxStyle = ScottPlot.Plottable.PopulationPlot.BoxStyle.BarMeanStDev;\n\n// improve the style of the plot\nplt.XAxis.Grid(false);\nplt.XTicks(populationNames);\n\nplt.SaveFig(\u0022population_data_over_bar.png\u0022);"
    },
    {
      "id": "population_multiSeries",
      "category": "Plottable: Population",
      "title": "Multiple Series",
      "description": "Multiple series of population groups can be plotted Here each group is clustered on the horizontal axis, and each series is given a different color and appears in the legend.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// Each class (A, B, C) is a series.\n// Each semester (fall, spring, summer A, summer B) is a group.\n\n// create sample data to represent test scores for each class in each semester\nRandom rand = new Random(0);\ndouble[] scoresAfall = DataGen.RandomNormal(rand, 35, 85, 5);\ndouble[] scoresBfall = DataGen.RandomNormal(rand, 42, 87, 5);\ndouble[] scoresCfall = DataGen.RandomNormal(rand, 23, 82, 5);\ndouble[] scoresAspring = DataGen.RandomNormal(rand, 35, 84, 3);\ndouble[] scoresBspring = DataGen.RandomNormal(rand, 42, 88, 3);\ndouble[] scoresCspring = DataGen.RandomNormal(rand, 23, 84, 3);\ndouble[] scoresAsumA = DataGen.RandomNormal(rand, 35, 80, 5);\ndouble[] scoresBsumA = DataGen.RandomNormal(rand, 42, 90, 5);\ndouble[] scoresCsumA = DataGen.RandomNormal(rand, 23, 85, 5);\ndouble[] scoresAsumB = DataGen.RandomNormal(rand, 35, 91, 2);\ndouble[] scoresBsumB = DataGen.RandomNormal(rand, 42, 93, 2);\ndouble[] scoresCsumB = DataGen.RandomNormal(rand, 23, 90, 2);\n\n// Collect multiple populations into a PopulationSeries.\n// All populations in a series will be styled the same and appear once in the legend.\nvar popsA = new Statistics.Population[] {\n    new Statistics.Population(scoresAfall),\n    new Statistics.Population(scoresAspring),\n    new Statistics.Population(scoresAsumA),\n    new Statistics.Population(scoresAsumB)\n};\n\nvar popsB = new Statistics.Population[] {\n    new Statistics.Population(scoresBfall),\n    new Statistics.Population(scoresBspring),\n    new Statistics.Population(scoresBsumA),\n    new Statistics.Population(scoresBsumB)\n};\n\nvar popsC = new Statistics.Population[] {\n    new Statistics.Population(scoresCfall),\n    new Statistics.Population(scoresCspring),\n    new Statistics.Population(scoresCsumA),\n    new Statistics.Population(scoresCsumB)\n};\n\n// create a population series for each array of populations and give it a label\nvar seriesA = new Statistics.PopulationSeries(popsA, \u0022Class A\u0022);\nvar seriesB = new Statistics.PopulationSeries(popsB, \u0022Class B\u0022);\nvar seriesC = new Statistics.PopulationSeries(popsC, \u0022Class C\u0022);\nvar allSeries = new Statistics.PopulationSeries[] { seriesA, seriesB, seriesC };\n\n// create a MultiSeries from multiple population series and plot it\nvar multiSeries = new Statistics.PopulationMultiSeries(allSeries);\nplt.AddPopulations(multiSeries);\n\n// improve the style of the plot\nstring[] groupNames = new string[] { \u0022Fall\u0022, \u0022Spring\u0022, \u0022Summer A\u0022, \u0022Summer B\u0022 };\nplt.XTicks(groupNames);\nplt.XAxis.Grid(false);\nplt.Legend();\n\nplt.SaveFig(\u0022population_multiSeries.png\u0022);"
    },
    {
      "id": "population_advanced",
      "category": "Plottable: Population",
      "title": "Advanced Population Styling",
      "description": "Populations can be displayed many different ways. Scatter values can be displayed on either side of the bar or bar. Populations can be shown as bar graphs instead of box plots. Public fields allow many additional customizations.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// create sample data to represent test scores\nRandom rand = new Random(0);\ndouble[] scoresA = DataGen.RandomNormal(rand, 35, 72, 7);\ndouble[] scoresB = DataGen.RandomNormal(rand, 42, 57, 10);\ndouble[] scoresC = DataGen.RandomNormal(rand, 23, 79, 5);\n\n// To create a population series we need to start with an array of populations.\n// In this example each population series just has one population in it.\nvar popsA = new Statistics.Population[] { new Statistics.Population(scoresA) };\nvar popsB = new Statistics.Population[] { new Statistics.Population(scoresB) };\nvar popsC = new Statistics.Population[] { new Statistics.Population(scoresC) };\n\n// create a PopulationSeries for each set of scores, naming it in the process\nvar seriesA = new Statistics.PopulationSeries(popsA, \u0022Class A\u0022);\nvar seriesB = new Statistics.PopulationSeries(popsB, \u0022Class B\u0022);\nvar seriesC = new Statistics.PopulationSeries(popsC, \u0022Class C\u0022);\nvar seriesArray = new Statistics.PopulationSeries[] { seriesA, seriesB, seriesC };\n\n// create a MultiSeries object by passing in the array of series objects and plot it\nvar multiSeries = new Statistics.PopulationMultiSeries(seriesArray);\nvar popPlot = plt.AddPopulations(multiSeries);\n\n// now customize its public fields to extensively customize its display options\npopPlot.DistributionCurve = true;\npopPlot.DistributionCurveLineStyle = LineStyle.Dash;\npopPlot.ScatterOutlineColor = System.Drawing.Color.Transparent;\npopPlot.DataFormat = ScottPlot.Plottable.PopulationPlot.DisplayItems.ScatterAndBox;\npopPlot.DataBoxStyle = ScottPlot.Plottable.PopulationPlot.BoxStyle.BarMeanStDev;\n\n// colors are managed at the population series level:\nforeach (var popSeries in popPlot.MultiSeries.multiSeries)\n    popSeries.color = Tools.GetRandomColor(rand);\n\n// improve the style of the plot\nplt.Legend(location: Alignment.LowerLeft);\nplt.XAxis.Ticks(false);\nplt.XAxis.Grid(false);\nplt.YAxis.MajorGrid(lineStyle: LineStyle.Dot);\nplt.SetAxisLimits(yMin: 0);\n\nplt.SaveFig(\u0022population_advanced.png\u0022);"
    },
    {
      "id": "radar_quickstart",
      "category": "Plottable: Radar",
      "title": "Radar",
      "description": "A radar chart concisely displays multiple values. Radar plots are also called a spider charts or star charts.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[,] values = {\n    { 78,  83, 84, 76, 43 },\n    { 100, 50, 70, 60, 90 }\n};\n\nplt.AddRadar(values);\n\n// improve plot styling\nplt.Frameless();\nplt.Grid(enable: false);\n\nplt.SaveFig(\u0022radar_quickstart.png\u0022);"
    },
    {
      "id": "radar_straightLines",
      "category": "Plottable: Radar",
      "title": "Straight Axis Lines",
      "description": "Change the axis type to polygon to display radar charts with straight lines.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[,] values = {\n        { 78, 83, 84, 76, 43 },\n        { 100, 50, 70, 60, 90 }\n    };\n\nvar radarPlot = plt.AddRadar(values);\nradarPlot.AxisType = RadarAxis.Polygon;\n\nplt.SaveFig(\u0022radar_straightLines.png\u0022);"
    },
    {
      "id": "radar_noLines",
      "category": "Plottable: Radar",
      "title": "No Axis Lines",
      "description": "A radar chart can have no drawn axis as well.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[,] values = {\n        { 78, 83, 84, 76, 43 },\n        { 100, 50, 70, 60, 90 }\n    };\n\nvar radarPlot = plt.AddRadar(values);\nradarPlot.AxisType = RadarAxis.None;\nradarPlot.ShowAxisValues = false;\n\nplt.SaveFig(\u0022radar_noLines.png\u0022);"
    },
    {
      "id": "radar_labelCategory",
      "category": "Plottable: Radar",
      "title": "Labeled Categories",
      "description": "Category labels can be displayed on the radar chart.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[,] values = {\n    { 5, 3, 10, 15, 3, 2, 256 },\n    { 5, 2, 10, 10, 1, 4, 252 },\n};\n\nvar radar = plt.AddRadar(values, independentAxes: true);\nradar.CategoryLabels = new string[] { \u0022Wins\u0022, \u0022Poles\u0022, \u0022Podiums\u0022, \u0022Points Finishes\u0022, \u0022DNFs\u0022, \u0022Fastest Laps\u0022, \u0022Points\u0022 };\nradar.GroupLabels = new[] { \u0022Sebastian Vettel\u0022, \u0022Fernando Alonso\u0022 };\nradar.ShowAxisValues = false;\n\n// customize the plot\nplt.Title(\u00222010 Formula One World Championship\u0022);\nplt.Legend();\n\n/* Data represents the 2010 Formula One World Championship\n * https://en.wikipedia.org/wiki/2010_Formula_One_World_Championship\n * Note: Alonso did not finish (DNF) in the Malaysian GP, but was included \n * here because he completed \u003E90% of the race distance.\n */\n\nplt.SaveFig(\u0022radar_labelCategory.png\u0022);"
    },
    {
      "id": "radar_labelValue",
      "category": "Plottable: Radar",
      "title": "Labeled Values",
      "description": "Labels can be displayed on the arms of the radar chart.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[,] values = {\n    { 5, 3, 10, 15, 3, 2 },\n    { 5, 2, 10, 10, 1, 4 },\n};\n\nvar radar = plt.AddRadar(values);\nradar.CategoryLabels = new string[] { \u0022Wins\u0022, \u0022Poles\u0022, \u0022Podiums\u0022, \u0022Points Finishes\u0022, \u0022DNFs\u0022, \u0022Fastest Laps\u0022 };\nradar.GroupLabels = new string[] { \u0022Sebastian Vettel\u0022, \u0022Fernando Alonso\u0022 };\n\n// customize the plot\nplt.Title(\u00222010 Formula One World Championship\u0022);\nplt.Legend();\n\n/* Data represents the 2010 Formula One World Championship\n * https://en.wikipedia.org/wiki/2010_Formula_One_World_Championship\n * Note: Alonso did not finish (DNF) in the Malaysian GP, but was included \n * here because he completed \u003E90% of the race distance.\n */\n\nplt.SaveFig(\u0022radar_labelValue.png\u0022);"
    },
    {
      "id": "radar_customizePolygonOutline",
      "category": "Plottable: Radar",
      "title": "Customizable polygon outline",
      "description": "The thickness of each radar plot\u0027s outline can be customized.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[,] values = {\n    { 5, 3, 10, 15, 3, 2 },\n    { 5, 2, 10, 10, 1, 4 },\n};\n\nvar radar = plt.AddRadar(values);\nradar.OutlineWidth = 3;\nradar.GroupLabels = new string[] { \u0022Sebastian Vettel\u0022, \u0022Fernando Alonso\u0022 };\nplt.Title(\u00222010 Formula One World Championship\u0022);\nplt.Legend();\n\n/* Data represents the 2010 Formula One World Championship\n * https://en.wikipedia.org/wiki/2010_Formula_One_World_Championship\n * Note: Alonso did not finish (DNF) in the Malaysian GP, but was included \n * here because he completed \u003E90% of the race distance.\n */\n\nplt.SaveFig(\u0022radar_customizePolygonOutline.png\u0022);"
    },
    {
      "id": "radar_iconValue",
      "category": "Plottable: Radar",
      "title": "Categories with images",
      "description": "Images can be displayed on the arms of the radar chart. When using images, labels will be ignored so setting them will have no effect.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[,] values = {\n    { 5, 15, 3, 2 },\n    { 5, 10, 1, 4 },\n};\n\nvar radar = plt.AddRadar(values);\nradar.CategoryImages = CategoryImages;\nradar.GroupLabels = new string[] { \u0022Sebastian Vettel\u0022, \u0022Fernando Alonso\u0022 };\n\n// customize the plot\nplt.Title(\u00222010 Formula One World Championship\u0022);\nplt.Legend();\n\n/* Data represents the 2010 Formula One World Championship\n * https://en.wikipedia.org/wiki/2010_Formula_One_World_Championship\n * Note: Alonso did not finish (DNF) in the Malaysian GP, but was included \n * here because he completed \u003E90% of the race distance.\n */\n\nplt.SaveFig(\u0022radar_iconValue.png\u0022);"
    },
    {
      "id": "radar_axisScaling",
      "category": "Plottable: Radar",
      "title": "Independent Axis Scaling",
      "description": "Axis scaling can be independent, allowing values for each category to be displayed using a different scale. When independent axis mode is enabled, axis limits are automatically adjusted to fit the range of the data.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[,] values = { { 5, 3, 10, 15, 3, 2, 256 }, { 5, 2, 10, 10, 1, 4, 252 }, };\n\nvar radar = plt.AddRadar(values, independentAxes: true);\nradar.CategoryLabels = new string[] { \u0022Wins\u0022, \u0022Poles\u0022, \u0022Podiums\u0022, \u0022Points Finishes\u0022, \u0022DNFs\u0022, \u0022Fastest Laps\u0022, \u0022Points\u0022 };\nradar.GroupLabels = new string[] { \u0022Sebastian Vettel\u0022, \u0022Fernando Alonso\u0022 };\n\n// customize the plot\nplt.Title(\u00222010 Formula One World Championship\u0022);\nplt.Legend();\n\n/* Data represents the 2010 Formula One World Championship\n * https://en.wikipedia.org/wiki/2010_Formula_One_World_Championship\n * Note: Alonso did not finish (DNF) in the Malaysian GP, but was included \n * here because he completed \u003E90% of the race distance.\n */\n\nplt.SaveFig(\u0022radar_axisScaling.png\u0022);"
    },
    {
      "id": "radar_axisLimits",
      "category": "Plottable: Radar",
      "title": "Defined Axis Limits",
      "description": "Radar charts with independent axis limits use scales fitted to the data by default, but scaling can be controlled by defining the maximum value for each axis.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[,] values = {\n    { 5, 3, 10, 15, 3, 2, 256 },\n    { 5, 2, 10, 10, 1, 4, 252 },\n};\n\ndouble[] maxValues = { 13, 15, 17, 15, 10, 10, 413 };\n\nvar radar = plt.AddRadar(values, independentAxes: true, maxValues: maxValues);\nradar.CategoryLabels = new string[] { \u0022Wins\u0022, \u0022Poles\u0022, \u0022Podiums\u0022, \u0022Points Finishes\u0022, \u0022DNFs\u0022, \u0022Fastest Laps\u0022, \u0022Points\u0022 };\nradar.GroupLabels = new string[] { \u0022Sebastian Vettel\u0022, \u0022Fernando Alonso\u0022 };\n\n// customize the plot\nplt.Title(\u00222010 Formula One World Championship\u0022);\nplt.Legend();\n\n/* Data represents the 2010 Formula One World Championship\n * https://en.wikipedia.org/wiki/2010_Formula_One_World_Championship\n * Note: Alonso did not finish (DNF) in the Malaysian GP, but was included \n * here because he completed \u003E90% of the race distance.\n *\n * Max values are based on https://en.wikipedia.org/wiki/List_of_Formula_One_World_Drivers%27_Champions.\n */\n\nplt.SaveFig(\u0022radar_axisLimits.png\u0022);"
    },
    {
      "id": "radar_customization",
      "category": "Plottable: Radar",
      "title": "Customization",
      "description": "Radar charts support customization of the line color and width.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[,] values = {\n    { 78,  83, 84, 76, 43 },\n    { 100, 50, 70, 60, 90 }\n};\n\nvar radar = plt.AddRadar(values);\nradar.WebColor = System.Drawing.Color.Red;\nradar.LineWidth = 3;\n\nplt.SaveFig(\u0022radar_customization.png\u0022);"
    },
    {
      "id": "radialgauge_quickstart",
      "category": "Plottable: RadialGauge",
      "title": "Radial Gauge",
      "description": "A radial gauge chart displays scalar data as circular gauges. ",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] values = { 100, 80, 65, 45, 20 };\nplt.AddRadialGauge(values);\n\nplt.SaveFig(\u0022radialgauge_quickstart.png\u0022);"
    },
    {
      "id": "radialgauge_colors",
      "category": "Plottable: RadialGauge",
      "title": "Gauge Colors",
      "description": "Gauge colors can be customized by changing the default palette. ",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] values = { 100, 80, 65, 45, 20 };\nplt.Palette = ScottPlot.Drawing.Palette.Nord;\nplt.AddRadialGauge(values);\n\nplt.SaveFig(\u0022radialgauge_colors.png\u0022);"
    },
    {
      "id": "radialgauge_negative",
      "category": "Plottable: RadialGauge",
      "title": "Negative Values",
      "description": "Radial gauge plots support positive and negative values.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.Palette = ScottPlot.Drawing.Palette.Nord;\ndouble[] values = { 100, 80, -65, 45, -20 };\nplt.AddRadialGauge(values);\n\nplt.SaveFig(\u0022radialgauge_negative.png\u0022);"
    },
    {
      "id": "radialgauge_mode",
      "category": "Plottable: RadialGauge",
      "title": "Sequential Gauge Mode",
      "description": "Sequential gauge mode indicates that the base of each gauge starts at the tip of the previous gauge.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.Palette = ScottPlot.Drawing.Palette.Nord;\ndouble[] values = { 100, 80, 65, 45, 50 };\n\nvar gauges = plt.AddRadialGauge(values);\ngauges.GaugeMode = ScottPlot.RadialGaugeMode.Sequential;\n\nplt.SaveFig(\u0022radialgauge_mode.png\u0022);"
    },
    {
      "id": "radialgauge_reverse",
      "category": "Plottable: RadialGauge",
      "title": "Reverse Order",
      "description": "Gauges are displayed from the center outward by default but the order can be customized.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.Palette = ScottPlot.Drawing.Palette.Nord;\ndouble[] values = { 100, 80, 65, 45, 50 };\n\nvar gauges = plt.AddRadialGauge(values);\ngauges.GaugeMode = ScottPlot.RadialGaugeMode.Sequential;\ngauges.OrderInsideOut = false;\n\nplt.SaveFig(\u0022radialgauge_reverse.png\u0022);"
    },
    {
      "id": "radialgauge_single",
      "category": "Plottable: RadialGauge",
      "title": "Single Gauge Mode",
      "description": "The SingleGauge mode draws all gauges stacked together as a single gauge. This is useful for showing a progress gauges composed of many individual smaller gauges.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.Palette = ScottPlot.Drawing.Palette.Nord;\ndouble[] values = { 100, 80, 65, 45 };\n\nvar gauges = plt.AddRadialGauge(values);\ngauges.GaugeMode = ScottPlot.RadialGaugeMode.SingleGauge;\ngauges.MaximumAngle = 180;\ngauges.StartingAngle = 180;\n\nplt.SaveFig(\u0022radialgauge_single.png\u0022);"
    },
    {
      "id": "radialgauge_direction",
      "category": "Plottable: RadialGauge",
      "title": "Gauge Direction",
      "description": "The direction of gauges can be customized. Clockwise is used by default.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.Palette = ScottPlot.Drawing.Palette.Nord;\ndouble[] values = { 100, 80, 65, 45, 20 };\n\nvar gauges = plt.AddRadialGauge(values);\ngauges.Clockwise = false;\n\nplt.SaveFig(\u0022radialgauge_direction.png\u0022);"
    },
    {
      "id": "radialgauge_size",
      "category": "Plottable: RadialGauge",
      "title": "Gauge Size",
      "description": "The empty space between gauges can be adjusted as a fraction of their width. ",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.Palette = ScottPlot.Drawing.Palette.Nord;\ndouble[] values = { 100, 80, 65, 45, 20 };\nvar gauges = plt.AddRadialGauge(values);\ngauges.SpaceFraction = .05;\n\nplt.SaveFig(\u0022radialgauge_size.png\u0022);"
    },
    {
      "id": "radialgauge_caps",
      "category": "Plottable: RadialGauge",
      "title": "Gauge Caps",
      "description": "Caps can be customized for the starting and end of the gauges. ",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.Palette = ScottPlot.Drawing.Palette.Nord;\ndouble[] values = { 100, 80, 65, 45, 20 };\n\nvar gauges = plt.AddRadialGauge(values);\ngauges.CircularBackground = false;\ngauges.StartCap = System.Drawing.Drawing2D.LineCap.Flat;\ngauges.EndCap = System.Drawing.Drawing2D.LineCap.DiamondAnchor;\n\nplt.SaveFig(\u0022radialgauge_caps.png\u0022);"
    },
    {
      "id": "radialgauge_start",
      "category": "Plottable: RadialGauge",
      "title": "Gauge Starting Angle",
      "description": "The starting angle for gauges can be customized. 270 for North (default value), 0 for East, 90 for South, 180 for West, etc.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.Palette = ScottPlot.Drawing.Palette.Nord;\ndouble[] values = { 100, 80, 65, 45, 20 };\n\nvar gauges = plt.AddRadialGauge(values);\ngauges.StartingAngle = 180;\n\nplt.SaveFig(\u0022radialgauge_start.png\u0022);"
    },
    {
      "id": "radialgauge_range",
      "category": "Plottable: RadialGauge",
      "title": "Gauge Angular Range",
      "description": "By default gauges are full circles (360 degrees) but smaller gauges can be created by customizing the gauge size.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.Palette = ScottPlot.Drawing.Palette.Nord;\ndouble[] values = { 100, 80, 65, 45, 20 };\n\nvar gauges = plt.AddRadialGauge(values);\ngauges.MaximumAngle = 180;\n\nplt.SaveFig(\u0022radialgauge_range.png\u0022);"
    },
    {
      "id": "radialgauge_levels",
      "category": "Plottable: RadialGauge",
      "title": "Show Levels",
      "description": "The value of each gauge is displayed as text by default but this behavior can be overridden. Note that this is different than the labels fiels which is what appears in the legened.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.Palette = ScottPlot.Drawing.Palette.Nord;\ndouble[] values = { 100, 80, 65, 45, 20 };\n\nvar gauges = plt.AddRadialGauge(values);\ngauges.ShowLevels = false;\n\nplt.SaveFig(\u0022radialgauge_levels.png\u0022);"
    },
    {
      "id": "radialgauge_labelpos",
      "category": "Plottable: RadialGauge",
      "title": "Gauge Label Position",
      "description": "Gauge level text is positioned at the tip of each gauge by default, but this position can be adjusted by the user.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.Palette = ScottPlot.Drawing.Palette.Nord;\ndouble[] values = { 100, 80, 65, 45, 20 };\n\nvar gauges = plt.AddRadialGauge(values);\ngauges.LabelPositionFraction = 0;\n\nplt.SaveFig(\u0022radialgauge_labelpos.png\u0022);"
    },
    {
      "id": "radialgauge_labelfontsize",
      "category": "Plottable: RadialGauge",
      "title": "Gauge Label Font Percentage",
      "description": "Size of the gauge level text as a fraction of the gauge width.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.Palette = ScottPlot.Drawing.Palette.Nord;\ndouble[] values = { 100, 80, 65, 45, 20 };\n\nvar gauges = plt.AddRadialGauge(values);\ngauges.FontSizeFraction = .4;\n\nplt.SaveFig(\u0022radialgauge_labelfontsize.png\u0022);"
    },
    {
      "id": "radialgauge_labelcolor",
      "category": "Plottable: RadialGauge",
      "title": "Gauge Label Color",
      "description": "Level text fonts may be customized.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.Palette = ScottPlot.Drawing.Palette.Nord;\ndouble[] values = { 100, 80, 65, 45, 20 };\n\nvar gauges = plt.AddRadialGauge(values);\ngauges.Font.Color = Color.Black;\n\nplt.SaveFig(\u0022radialgauge_labelcolor.png\u0022);"
    },
    {
      "id": "radialgauge_legend",
      "category": "Plottable: RadialGauge",
      "title": "Gauge Labels in Legend",
      "description": "Radial gauge labels will appear in the legend if they are assigned. ",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.Palette = ScottPlot.Drawing.Palette.Nord;\ndouble[] values = { 100, 80, 65, 45, 20 };\n\nvar gauges = plt.AddRadialGauge(values);\ngauges.Labels = new string[] { \u0022alpha\u0022, \u0022beta\u0022, \u0022gamma\u0022, \u0022delta\u0022, \u0022epsilon\u0022 };\nplt.Legend(true);\n\nplt.SaveFig(\u0022radialgauge_legend.png\u0022);"
    },
    {
      "id": "radialgauge_backdim",
      "category": "Plottable: RadialGauge",
      "title": "Background Gauges Dim",
      "description": "By default the full range of each gauge is drawn as a semitransparent ring. The amount of transparency can be adjusted as desired.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.Palette = ScottPlot.Drawing.Palette.Nord;\ndouble[] values = { 100, 80, 65, 45, 20 };\n\nvar gauges = plt.AddRadialGauge(values);\ngauges.BackgroundTransparencyFraction = .5;\n\nplt.SaveFig(\u0022radialgauge_backdim.png\u0022);"
    },
    {
      "id": "radialgauge_backnorm",
      "category": "Plottable: RadialGauge",
      "title": "Background Gauges Normalization",
      "description": "Gauge backgrounds are drawn as full circles by default. This behavior can be disabled to draw partial backgrounds for non-circular gauges.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nplt.Palette = ScottPlot.Drawing.Palette.Nord;\ndouble[] values = { 100, 80, 65, 45, 20 };\n\nvar gauges = plt.AddRadialGauge(values);\ngauges.CircularBackground = false;\ngauges.MaximumAngle = 180;\ngauges.StartingAngle = 180;\n\nplt.SaveFig(\u0022radialgauge_backnorm.png\u0022);"
    },
    {
      "id": "scalebar_quickstart",
      "category": "Plottable: Scale Bar",
      "title": "Scale Bar",
      "description": "An L-shaped scalebar can be added in the corner of any plot. Set the vertical or horizontal sizer to zero and the scale bar will only span one dimension.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// plot sample data\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\n// remove traditional scale indicators\nplt.Grid(enable: false);\nplt.Frameless();\n\n// add an L-shaped scalebar\nplt.AddScaleBar(5, .25, \u0022100 ms\u0022, \u0022250 mV\u0022);\n\nplt.SaveFig(\u0022scalebar_quickstart.png\u0022);"
    },
    {
      "id": "scalebar_horizontal",
      "category": "Plottable: Scale Bar",
      "title": "Horizontal Scale Bar",
      "description": "Set the vertical or horizontal sizer to zero and the scale bar will only span one dimension.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// plot sample data \nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\n// show only the left axis\nplt.XAxis.Hide();\nplt.XAxis2.Hide();\nplt.YAxis2.Hide();\nplt.Grid(enable: false);\n\n// add a horizontal scale bar (no Y height)\nplt.AddScaleBar(5, 0, \u0022100 ms\u0022, null);\n\nplt.SaveFig(\u0022scalebar_horizontal.png\u0022);"
    },
    {
      "id": "scalebar_styled",
      "category": "Plottable: Scale Bar",
      "title": "Styled Scale Bar",
      "description": "An L-shaped scalebar can be added in the corner of any plot. Set the vertical or horizontal sizer to zero and the scale bar will only span one dimension.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// plot sample data\nplt.AddSignal(DataGen.Sin(51));\nplt.AddSignal(DataGen.Cos(51));\n\n// remove traditional scale indicators\nplt.Grid(enable: false);\nplt.Frameless();\n\n// add an L-shaped scalebar\nplt.AddScaleBar(5, .25, \u0022100 ms\u0022, \u0022250 mV\u0022);\n\n// add style\nplt.Style(Style.Black);\n\nplt.SaveFig(\u0022scalebar_styled.png\u0022);"
    },
    {
      "id": "scatter_quickstart",
      "category": "Plottable: Scatter Plot",
      "title": "Scatter Plot Quickstart",
      "description": "Scatter plots are best for small numbers of paired X/Y data points. For evenly-spaced data points Signal is much faster.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// create sample X/Y data\nint pointCount = 51;\ndouble[] x = DataGen.Consecutive(pointCount);\ndouble[] sin = DataGen.Sin(pointCount);\ndouble[] cos = DataGen.Cos(pointCount);\n\n// add scatter plots\nplt.AddScatter(x, sin);\nplt.AddScatter(x, cos);\n\nplt.SaveFig(\u0022scatter_quickstart.png\u0022);"
    },
    {
      "id": "scatter_markers",
      "category": "Plottable: Scatter Plot",
      "title": "Custom markers",
      "description": "Markers can be customized using optional arguments and public fields.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nint pointCount = 51;\ndouble[] x = DataGen.Consecutive(pointCount);\ndouble[] sin = DataGen.Sin(pointCount);\ndouble[] cos = DataGen.Cos(pointCount);\n\n// add scatter plots and customize markers\nvar sp1 = plt.AddScatter(x, sin, markerSize: 15);\nsp1.MarkerShape = MarkerShape.openCircle;\n\nvar sp2 = plt.AddScatter(x, cos, markerSize: 7);\nsp2.MarkerShape = MarkerShape.filledSquare;\n\nplt.SaveFig(\u0022scatter_markers.png\u0022);"
    },
    {
      "id": "scatter_markerShape",
      "category": "Plottable: Scatter Plot",
      "title": "All marker shapes",
      "description": "Legend indicates names of all available marker shapes",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nint pointCount = 51;\ndouble[] xs = DataGen.Consecutive(pointCount);\n\nstring[] markerShapeNames = Enum.GetNames(typeof(MarkerShape));\nfor (int i = 0; i \u003C markerShapeNames.Length; i\u002B\u002B)\n{\n    Enum.TryParse(markerShapeNames[i], out MarkerShape ms);\n    double[] ys = DataGen.Sin(pointCount, 2, -i);\n    var sp = plt.AddScatter(xs, ys);\n    sp.LineWidth = 2;\n    sp.LineColor = Color.FromArgb(50, sp.LineColor);\n    sp.MarkerSize = 7;\n    sp.MarkerShape = ms;\n    sp.Label = ms.ToString();\n}\n\nplt.Grid(enable: false);\nvar legend = plt.Legend();\nlegend.FontSize = 10;\n\nplt.SaveFig(\u0022scatter_markerShape.png\u0022);"
    },
    {
      "id": "scatter_lineStyle",
      "category": "Plottable: Scatter Plot",
      "title": "Custom lines",
      "description": "Line color, size, and style can be customized. Setting markerSize to 0 prevents markers from being rendered.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nint pointCount = 51;\ndouble[] x = DataGen.Consecutive(pointCount);\ndouble[] sin = DataGen.Sin(pointCount);\ndouble[] cos = DataGen.Cos(pointCount);\ndouble[] cos2 = DataGen.Cos(pointCount, mult: -1);\n\nplt.AddScatter(x, sin, color: Color.Magenta, lineWidth: 0, markerSize: 10);\nplt.AddScatter(x, cos, color: Color.Green, lineWidth: 5, markerSize: 0);\nplt.AddScatter(x, cos2, color: Color.Blue, lineWidth: 3, markerSize: 0, lineStyle: LineStyle.DashDot);\n\nvar legend = plt.Legend();\nlegend.FixedLineWidth = false;\n\nplt.SaveFig(\u0022scatter_lineStyle.png\u0022);"
    },
    {
      "id": "scatter_random",
      "category": "Plottable: Scatter Plot",
      "title": "Random X/Y Points",
      "description": "X data for scatter plots does not have to be evenly spaced, making scatter plots are ideal for displaying random data like this.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nRandom rand = new Random(0);\nint pointCount = 51;\ndouble[] xs1 = DataGen.RandomNormal(rand, pointCount, 1);\ndouble[] xs2 = DataGen.RandomNormal(rand, pointCount, 3);\ndouble[] ys1 = DataGen.RandomNormal(rand, pointCount, 5);\ndouble[] ys2 = DataGen.RandomNormal(rand, pointCount, 7);\n\nplt.AddScatter(xs1, ys1, markerSize: 0, label: \u0022lines only\u0022);\nplt.AddScatter(xs2, ys2, lineWidth: 0, label: \u0022markers only\u0022);\nplt.Legend();\n\nplt.SaveFig(\u0022scatter_random.png\u0022);"
    },
    {
      "id": "scatter_errorbar",
      "category": "Plottable: Scatter Plot",
      "title": "Scatter Plot with Errorbars",
      "description": "An array of values can be supplied for error bars and redering options can be customized as desired",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nint pointCount = 20;\nRandom rand = new Random(0);\ndouble[] xs = DataGen.Consecutive(pointCount);\ndouble[] ys = DataGen.RandomWalk(rand, pointCount);\ndouble[] xErr = DataGen.RandomNormal(rand, pointCount, .2);\ndouble[] yErr = DataGen.RandomNormal(rand, pointCount);\n\nvar sp = plt.AddScatter(xs, ys);\nsp.XError = xErr;\nsp.YError = yErr;\nsp.ErrorCapSize = 3;\nsp.ErrorLineWidth = 1;\nsp.LineStyle = LineStyle.Dot;\n\nplt.SaveFig(\u0022scatter_errorbar.png\u0022);"
    },
    {
      "id": "scatter_lineplot",
      "category": "Plottable: Scatter Plot",
      "title": "Lines Only",
      "description": "A shortcut method makes it easy to create a scatter plot with just lines (no markers)",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] xs = DataGen.Consecutive(51);\ndouble[] ys = DataGen.Sin(51);\n\nplt.AddScatterLines(xs, ys, Color.Red, 3);\n\nplt.SaveFig(\u0022scatter_lineplot.png\u0022);"
    },
    {
      "id": "scatter_pointsplot",
      "category": "Plottable: Scatter Plot",
      "title": "Markers Only",
      "description": "A shortcut method makes it easy to create a scatter plot where markers are displayed at every point (without any connecting lines)",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] xs = DataGen.Consecutive(51);\ndouble[] ys = DataGen.Sin(51);\n\nplt.AddScatterPoints(xs, ys, Color.Navy, 10, MarkerShape.filledDiamond);\n\nplt.SaveFig(\u0022scatter_pointsplot.png\u0022);"
    },
    {
      "id": "scatter_stepplot",
      "category": "Plottable: Scatter Plot",
      "title": "Step Plot",
      "description": "A step plot is a special type of scatter plot where points are connected by right angles instead of straight lines.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] xs = DataGen.Consecutive(51);\ndouble[] ys = DataGen.Sin(51);\n\nplt.AddScatterStep(xs, ys);\n\nplt.SaveFig(\u0022scatter_stepplot.png\u0022);"
    },
    {
      "id": "scatter_AddMarker",
      "category": "Plottable: Scatter Plot",
      "title": "Add markers",
      "description": "Want to place a marker at a position in X/Y space? AddMarker() will create a scatter plot with a single point.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nRandom rand = new(0);\nfor (int i = 0; i \u003C 100; i\u002B\u002B)\n{\n    double x = rand.Next(100);\n    double y = rand.Next(100);\n    double fraction = rand.NextDouble();\n    double size = (fraction \u002B .1) * 30;\n    var color = Drawing.Colormap.Turbo.GetColor(fraction, alpha: .8);\n    var shape = Marker.Random(rand);\n    plt.AddMarker(x, y, shape, size, color);\n}\n\nplt.SaveFig(\u0022scatter_AddMarker.png\u0022);"
    },
    {
      "id": "scatter_draggable_vertical",
      "category": "Plottable: Scatter Plot",
      "title": "Draggable Scatter Plot",
      "description": "Want to modify the scatter points interactively? A ScatterPlotDraggable lets you move the points around with the mouse. As you move the points around, the values in the original arrays change to reflect their new positions.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] x = ScottPlot.DataGen.Consecutive(50);\ndouble[] y = ScottPlot.DataGen.Cos(50);\n\nvar scatter = new ScottPlot.Plottable.ScatterPlotDraggable(x, y)\n{\n    DragCursor = Cursor.Crosshair,\n    DragEnabled = true,\n};\n\nplt.Add(scatter);\n\nplt.SaveFig(\u0022scatter_draggable_vertical.png\u0022);"
    },
    {
      "id": "scatter_draggable",
      "category": "Plottable: Scatter Plot",
      "title": "Draggable Scatter Plot Vertical",
      "description": "You can restrict dragging to just X or Y directions.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] x = ScottPlot.DataGen.Consecutive(50);\ndouble[] y = ScottPlot.DataGen.Cos(50);\n\nvar scatter = new ScottPlot.Plottable.ScatterPlotDraggable(x, y)\n{\n    DragCursor = Cursor.Crosshair,\n    DragEnabled = true,   // controls whether anything can be dragged\n    DragEnabledX = false, // controls whether points can be dragged horizontally \n    DragEnabledY = true,  // controls whether points can be dragged vertically\n};\n\nplt.Add(scatter);\n\nplt.SaveFig(\u0022scatter_draggable.png\u0022);"
    },
    {
      "id": "scatter_forest",
      "category": "Plottable: Scatter Plot",
      "title": "Forest Plot",
      "description": "Scatter plots can be used to create forest plots, which are useful for showing the agreement between multiple estimates.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nvar plot1 = plt.AddScatter(new double[] { 2.5 }, new double[] { 5 }, label: \u0022John Doe et al.\u0022);\nplot1.XError = new double[] { 0.2 };\n\nvar plot2 = plt.AddScatter(new double[] { 2.7 }, new double[] { 4 }, label: \u0022Jane Doe et al.\u0022);\nplot2.XError = new double[] { 0.3 };\n\nvar plot3 = plt.AddScatter(new double[] { 2.3 }, new double[] { 3 }, label: \u0022Jim Doe et al.\u0022);\nplot3.XError = new double[] { 0.6 };\n\nvar plot4 = plt.AddScatter(new double[] { 2.8 }, new double[] { 2 }, label: \u0022Joel Doe et al.\u0022);\nplot4.XError = new double[] { 0.3 };\n\nvar plot5 = plt.AddScatter(new double[] { 2.5 }, new double[] { 1 }, label: \u0022Jacqueline Doe et al.\u0022);\nplot5.XError = new double[] { 0.2 };\n\nplt.AddVerticalLine(2.6, style: LineStyle.Dash);\n\nplt.SetAxisLimits(0, 5, 0, 6);\nplt.Legend();\n\nplt.SaveFig(\u0022scatter_forest.png\u0022);"
    },
    {
      "id": "scatterList_quickstart",
      "category": "Plottable: Scatter Plot List",
      "title": "Scatter List Quickstart",
      "description": "This experimental plot type has add/remove/clear methods like typical lists.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] xs = { 1, 2, 3, 4 };\ndouble[] ys = { 1, 4, 9, 16 };\n\nvar scatterList = plt.AddScatterList();\nscatterList.AddRange(xs, ys);\nscatterList.Add(5, 25);\n\nplt.SaveFig(\u0022scatterList_quickstart.png\u0022);"
    },
    {
      "id": "scatterList_generic",
      "category": "Plottable: Scatter Plot List",
      "title": "Scatter List Generic",
      "description": "This plot type supports generics.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nint[] xs = { 1, 2, 3, 4 };\nint[] ys = { 1, 4, 9, 16 };\n\nvar scatterList = plt.AddScatterList\u003Cint\u003E();\nscatterList.AddRange(xs, ys);\nscatterList.Add(5, 25);\n\nplt.SaveFig(\u0022scatterList_generic.png\u0022);"
    },
    {
      "id": "scatterList_draggable",
      "category": "Plottable: Scatter Plot List",
      "title": "Scatter List Draggable",
      "description": "There exists an experimental Scatter Plot List with draggable points.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] xs = ScottPlot.DataGen.Consecutive(51);\ndouble[] ys = ScottPlot.DataGen.Sin(51);\n\nvar scatter = new ScottPlot.Plottable.ScatterPlotListDraggable();\nscatter.AddRange(xs, ys);\n\nplt.Add(scatter);\n\nplt.SaveFig(\u0022scatterList_draggable.png\u0022);"
    },
    {
      "id": "scatterList_draggableLimits",
      "category": "Plottable: Scatter Plot List",
      "title": "Scatter List Draggable Limits",
      "description": "A custom function can be used to limit the range of draggable points.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// plot sample data\ndouble[] xs = ScottPlot.DataGen.Consecutive(20);\ndouble[] ys = ScottPlot.DataGen.Sin(20);\nvar scatter = new ScottPlot.Plottable.ScatterPlotListDraggable();\nscatter.AddRange(xs, ys);\nscatter.MarkerSize = 5;\nplt.Add(scatter);\n\n// use a custom function to limit the movement of points\nstatic Coordinate MoveBetweenAdjacent(List\u003Cdouble\u003E xs, List\u003Cdouble\u003E ys, int index, Coordinate requested)\n{\n    int leftIndex = Math.Max(index - 1, 0);\n    int rightIndex = Math.Min(index \u002B 1, xs.Count - 1);\n\n    double newX = requested.X;\n    newX = Math.Max(newX, xs[leftIndex]);\n    newX = Math.Min(newX, xs[rightIndex]);\n\n    return new Coordinate(newX, requested.Y);\n}\n\nscatter.MovePointFunc = MoveBetweenAdjacent;\n\nplt.SaveFig(\u0022scatterList_draggableLimits.png\u0022);"
    },
    {
      "id": "signal_quickstart",
      "category": "Plottable: Signal Plot",
      "title": "Signal Plot Quickstart",
      "description": "Signal plots are ideal for evenly-spaced data with thousands or millions of points.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nvar rand = new Random(0);\ndouble[] values = DataGen.RandomWalk(rand, 100_000);\nint sampleRate = 20_000;\n\n// Signal plots require a data array and a sample rate (points per unit)\nplt.AddSignal(values, sampleRate);\n\nplt.Benchmark(enable: true);\nplt.Title($\u0022Signal Plot: One Million Points\u0022);\n\nplt.SaveFig(\u0022signal_quickstart.png\u0022);"
    },
    {
      "id": "signal_offset",
      "category": "Plottable: Signal Plot",
      "title": "Signal Offset",
      "description": "Signal plots can have X and Y offsets that shift all data by a defined amount.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nvar rand = new Random(0);\ndouble[] values = DataGen.RandomWalk(rand, 100_000);\nvar sig = plt.AddSignal(values);\nsig.OffsetX = 10_000;\nsig.OffsetY = 100;\n\nplt.SaveFig(\u0022signal_offset.png\u0022);"
    },
    {
      "id": "signal_advantage",
      "category": "Plottable: Signal Plot",
      "title": "Speed Test",
      "description": "Compare the speed to the same data plotted as a scatter plot.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] xs = DataGen.Consecutive(100_000, 1.0 / 20_000);\ndouble[] values = DataGen.RandomWalk(null, 100_000);\n\nplt.AddScatter(xs, values, Color.Red, markerSize: 0);\n\nplt.Benchmark(enable: true);\nplt.Title($\u0022Scatter Plot: One Million Points\u0022);\n\nplt.SaveFig(\u0022signal_advantage.png\u0022);"
    },
    {
      "id": "signal_styled",
      "category": "Plottable: Signal Plot",
      "title": "Styled Signal Plot",
      "description": "Signal plots can be styled using public fields. Signal plots can also be offset by a defined X or Y amount.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] ys = DataGen.RandomWalk(null, 500);\nint sampleRate = 10;\n\nvar sp2 = plt.AddSignal(ys, sampleRate, Color.Magenta);\nsp2.OffsetY = 1000;\nsp2.OffsetX = 300;\nsp2.LineStyle = LineStyle.Dash;\nsp2.LineWidth = 2;\n\nplt.SaveFig(\u0022signal_styled.png\u0022);"
    },
    {
      "id": "signal_step",
      "category": "Plottable: Signal Plot",
      "title": "Step Display",
      "description": "Signal plots can be styled as step plots where points are connected by right angles instead of straight lines.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] ys = DataGen.Sin(51);\n\nvar sig = plt.AddSignal(ys);\nsig.StepDisplay = true;\nsig.MarkerSize = 0;\n\nplt.SaveFig(\u0022signal_step.png\u0022);"
    },
    {
      "id": "signal_5millionPoints",
      "category": "Plottable: Signal Plot",
      "title": "5 Million Points",
      "description": "Signal plots with millions of points can be interacted with in real time.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nRandom rand = new Random(0);\nfor (int i = 0; i \u003C 5; i\u002B\u002B)\n{\n    // add a new signal plot with one million points\n    double[] values = DataGen.RandomWalk(rand, 1_000_000);\n    plt.AddSignal(values);\n}\nplt.Benchmark(enable: true);\n\nplt.SaveFig(\u0022signal_5millionPoints.png\u0022);"
    },
    {
      "id": "signal_density",
      "category": "Plottable: Signal Plot",
      "title": "Display data density",
      "description": "When plotting extremely high density data, you can\u0027t always see the trends underneath all those overlapping data points. If you send an array of colors to PlotSignal(), it will use those colors to display density.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// create an extremely noisy signal with a subtle sine wave beneath it\nRandom rand = new Random(0);\nint pointCount = 100_000;\ndouble[] signal1 = DataGen.Sin(pointCount, 3);\ndouble[] noise = DataGen.RandomNormal(rand, pointCount, 0, 5);\ndouble[] data = new double[pointCount];\nfor (int i = 0; i \u003C data.Length; i\u002B\u002B)\n    data[i] = signal1[i] \u002B noise[i];\n\n// plot the noisy signal using the traditional method\nvar sp1 = plt.AddSignal(data);\nsp1.OffsetY = -40;\nsp1.Color = Color.Red;\n\n// use a custom colors to display data of different densities\nstring[] colorCodes = { \u0022#440154\u0022, \u0022#39568C\u0022, \u0022#1F968B\u0022, \u0022#73D055\u0022 };\nColor[] colors = colorCodes.Select(x =\u003E ColorTranslator.FromHtml(x)).ToArray();\n\nvar sp2 = plt.AddSignal(data);\nsp2.DensityColors = colors;\nsp2.Color = colors[0];\n\nplt.Title(\u0022Color by Density vs. Solid Color\u0022);\nplt.AxisAuto(0, .1);\n\nplt.SaveFig(\u0022signal_density.png\u0022);"
    },
    {
      "id": "signal_firstNpoints",
      "category": "Plottable: Signal Plot",
      "title": "Display first N points",
      "description": "When plotting live data it is useful to allocate a large array in memory then fill it with values as they come in. By setting the maxRenderIndex property of a scatter plot to can prevent rendering the end of the array (which is probably filled with zeros).",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// create an array larger than we intend to display\ndouble[] values = DataGen.RandomWalk(1000);\n\n// only render the first N points of the signal\nvar sig = plt.AddSignal(values);\nsig.MaxRenderIndex = 500;\n\nplt.SaveFig(\u0022signal_firstNpoints.png\u0022);"
    },
    {
      "id": "signal_range",
      "category": "Plottable: Signal Plot",
      "title": "Plot a Range of Points",
      "description": "It is sometimes useful to only display values within a range of the source data array.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// create an array larger than we intend to display\ndouble[] values = DataGen.RandomWalk(1000);\n\n// only render values between the two defined indexes\nvar sig = plt.AddSignal(values);\nsig.MinRenderIndex = 400;\nsig.MaxRenderIndex = 500;\n\nplt.SaveFig(\u0022signal_range.png\u0022);"
    },
    {
      "id": "signal_fillBelow",
      "category": "Plottable: Signal Plot",
      "title": "Fill Below",
      "description": "Signal plots can be filled below with a solid color.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] data = DataGen.RandomWalk(1000);\n\nvar sig = plt.AddSignal(data);\nsig.FillBelow();\n\nplt.Margins(x: 0);\n\nplt.SaveFig(\u0022signal_fillBelow.png\u0022);"
    },
    {
      "id": "signal_fillBelowGradient",
      "category": "Plottable: Signal Plot",
      "title": "Gradient Fill Below",
      "description": "Signal plots can be filled below using a color gradient.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] data = DataGen.RandomWalk(1000);\n\nvar sig = plt.AddSignal(data);\nsig.FillBelow(Color.Blue, Color.Transparent);\n\nplt.Margins(x: 0);\n\nplt.SaveFig(\u0022signal_fillBelowGradient.png\u0022);"
    },
    {
      "id": "signal_fillAbove",
      "category": "Plottable: Signal Plot",
      "title": "Gradient Fill Above",
      "description": "Signal plots can be filled above using a color gradient.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] data = DataGen.RandomWalk(1000);\n\nvar sig = plt.AddSignal(data);\nsig.FillAbove(Color.Blue, Color.Transparent);\n\nplt.Margins(x: 0);\n\nplt.SaveFig(\u0022signal_fillAbove.png\u0022);"
    },
    {
      "id": "signal_fillAboveAndBelow",
      "category": "Plottable: Signal Plot",
      "title": "Fill Above and Below",
      "description": "Signal plots can be filled above and below",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] data = DataGen.RandomWalk(1000);\n\nvar sig = plt.AddSignal(data);\nsig.FillAboveAndBelow(Color.Green, Color.Red);\nsig.Color = Color.Black;\nsig.BaselineY = 7;\n\nplt.Margins(x: 0);\n\nplt.SaveFig(\u0022signal_fillAboveAndBelow.png\u0022);"
    },
    {
      "id": "signal_gradientAboveAndBelowGradient",
      "category": "Plottable: Signal Plot",
      "title": "Gradient Fill Above and Below",
      "description": "Gradients can be used to fill above and below.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] data = DataGen.RandomWalk(1000);\n\nplt.Style(Style.Gray1);\n\nvar sig = plt.AddSignal(data);\nsig.MarkerSize = 0;\nsig.Color = Color.Black;\nsig.FillAboveAndBelow(Color.Green, Color.Transparent, Color.Transparent, Color.Red, 1);\nsig.BaselineY = 5;\n\nplt.Margins(x: 0);\n\nplt.SaveFig(\u0022signal_gradientAboveAndBelowGradient.png\u0022);"
    },
    {
      "id": "signalconst_quickstart",
      "category": "Plottable: SignalConst",
      "title": "SignalConst Quickstart",
      "description": "SignalConst plots pre-processes data to render much faster than Signal plots. Pre-processing takes a little time up-front and requires 4x the memory of Signal.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] values = DataGen.RandomWalk(1_000_000);\nplt.AddSignalConst(values);\nplt.Title(\u0022One Million Points\u0022);\nplt.Benchmark();\n\nplt.SaveFig(\u0022signalconst_quickstart.png\u0022);"
    },
    {
      "id": "signalconst_generic",
      "category": "Plottable: SignalConst",
      "title": "Generic Data Type",
      "description": "SignalConst supports other data types beyond just double arrays. You can use this plot type to display data in any numerical format that can be cast to a double.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nint[] data = { 2, 6, 3, 8, 5, 6, 1, 9, 7 };\nplt.AddSignalConst(data);\nplt.Title(\u0022SignalConst Displaying int[] Data\u0022);\n\nplt.SaveFig(\u0022signalconst_generic.png\u0022);"
    },
    {
      "id": "signalxy_quickstart",
      "category": "Plottable: SignalXY",
      "title": "SignalXY Quickstart",
      "description": "SignalXY is a speed-optimized plot for displaying vaues (Ys) with unevenly-spaced positions (Xs) that are in ascending order. If your data is evenly-spaced, Signal and SignalConst is faster.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n(double[] xs, double[] ys) = DataGen.RandomWalk2D(new Random(0), 5_000);\n\nplt.AddSignalXY(xs, ys);\n\nplt.SaveFig(\u0022signalxy_quickstart.png\u0022);"
    },
    {
      "id": "signalxy_offset",
      "category": "Plottable: SignalXY",
      "title": "SignalXY Offset",
      "description": "SignalXY plots can have X and Y offsets that shift all data by a defined amount.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n(double[] xs, double[] ys) = DataGen.RandomWalk2D(new Random(0), 5_000);\n\nvar sig = plt.AddSignalXY(xs, ys);\nsig.OffsetX = 10_000;\nsig.OffsetY = 100;\n\nplt.SaveFig(\u0022signalxy_offset.png\u0022);"
    },
    {
      "id": "signalxy_gaps",
      "category": "Plottable: SignalXY",
      "title": "Signal Data with Gaps",
      "description": "Signal with defined Xs that contain gaps",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nvar rand = new Random(0);\nint pointCount = 10_000;\ndouble[] sine = DataGen.Sin(pointCount, 3);\ndouble[] noise = DataGen.RandomNormal(rand, pointCount, 0, 0.5);\ndouble[] ys = sine.Zip(noise, (s, n) =\u003E s \u002B n).ToArray();\ndouble[] xs = Enumerable.Range(0, pointCount)\n    .Select(x =\u003E (double)x)\n    .Select(x =\u003E x \u003E 3_000 ? x \u002B 10_000 : x)\n    .Select(x =\u003E x \u003E 7_000 ? x \u002B 20_000 : x)\n    .ToArray();\n\nplt.AddSignalXY(xs, ys);\n\nplt.SaveFig(\u0022signalxy_gaps.png\u0022);"
    },
    {
      "id": "signalxy_density",
      "category": "Plottable: SignalXY",
      "title": "Different Densities",
      "description": "Signal with mised low and high density data",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nRandom rand = new(0);\nint pointCount = 5_000;\ndouble[] sine = DataGen.Sin(pointCount, 3);\ndouble[] noise = DataGen.RandomNormal(rand, pointCount, 0, 0.5);\ndouble[] ys = sine.Zip(noise, (s, n) =\u003E s \u002B n).ToArray();\ndouble[] xs = new double[pointCount];\n\ndouble x = 0;\nfor (int i = 0; i \u003C pointCount; i\u002B\u002B)\n{\n    bool lowDensityPoint = (i % 1_000) \u003C 10;\n    x \u002B= lowDensityPoint ? 10 : .05;\n    xs[i] = x;\n}\n\nplt.AddSignalXY(xs, ys);\n\nplt.SaveFig(\u0022signalxy_density.png\u0022);"
    },
    {
      "id": "signalxy_step",
      "category": "Plottable: SignalXY",
      "title": "SignalXY Step Mode",
      "description": "Data points can be connected with steps (instead of straight lines).",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n(double[] xs, double[] ys) = DataGen.RandomWalk2D(new Random(0), 5_000);\n\nvar sigxy = plt.AddSignalXY(xs, ys);\nsigxy.StepDisplay = true;\nsigxy.MarkerSize = 0;\n\nplt.SetAxisLimits(110, 140, 17.5, 27.5);\n\nplt.SaveFig(\u0022signalxy_step.png\u0022);"
    },
    {
      "id": "signalxy_fillBelow",
      "category": "Plottable: SignalXY",
      "title": "SignalXY with Fill",
      "description": "Various options allow shading above/below the signal data.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n(double[] xs, double[] ys) = DataGen.RandomWalk2D(new Random(0), 5_000);\n\nvar sigxy = plt.AddSignalXY(xs, ys);\nsigxy.FillBelow();\n\nplt.Margins(x: 0);\n\nplt.SaveFig(\u0022signalxy_fillBelow.png\u0022);"
    },
    {
      "id": "signalxyconst_quickstart",
      "category": "Plottable: SignalXYConst",
      "title": "SignalConst with X and Y data",
      "description": "SignalXYConst is a speed-optimized plot for displaying vaues (Ys) with unevenly-spaced positions (Xs) that are in ascending order. If your data is evenly-spaced, Signal and SignalConst is faster.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// generate random, unevenly-spaced data\nRandom rand = new Random(0);\nint pointCount = 100_000;\ndouble[] ys = new double[pointCount];\ndouble[] xs = new double[pointCount];\nfor (int i = 1; i \u003C ys.Length; i\u002B\u002B)\n{\n    ys[i] = ys[i - 1] \u002B rand.NextDouble() - .5;\n    xs[i] = xs[i - 1] \u002B rand.NextDouble();\n}\n\nplt.AddSignalXYConst(xs, ys);\n\nplt.SaveFig(\u0022signalxyconst_quickstart.png\u0022);"
    },
    {
      "id": "signalxyconst_types",
      "category": "Plottable: SignalXYConst",
      "title": "Different data types for xs and ys",
      "description": "SignalXYConst with (int)Xs and (float)Ys arrays",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nRandom rand = new Random(0);\nint pointCount = 1_000_000;\ndouble[] sine = DataGen.Sin(pointCount, 3);\ndouble[] noise = DataGen.RandomNormal(rand, pointCount, 0, 0.5);\nfloat[] ys = sine.Zip(noise, (s, n) =\u003E s \u002B n).Select(x =\u003E (float)x).ToArray();\nint[] xs = Enumerable.Range(0, pointCount)\n    .Select(x =\u003E (int)x)\n    .Select(x =\u003E x \u003E 500_000 ? x \u002B 1_000_000 : x)\n    .Select(x =\u003E x \u003E 200_000 ? x \u002B 100_000 : x)\n    .ToArray();\n\nplt.AddSignalXYConst(xs, ys);\n\nplt.SaveFig(\u0022signalxyconst_types.png\u0022);"
    },
    {
      "id": "signalxyconst_step",
      "category": "Plottable: SignalXYConst",
      "title": "SignalConst Step Mode",
      "description": "Data points can be connected with steps (instead of straight lines).",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// generate random, unevenly-spaced data\nRandom rand = new Random(0);\nint pointCount = 100_000;\ndouble[] ys = new double[pointCount];\ndouble[] xs = new double[pointCount];\nfor (int i = 1; i \u003C ys.Length; i\u002B\u002B)\n{\n    ys[i] = ys[i - 1] \u002B rand.NextDouble() - .5;\n    xs[i] = xs[i - 1] \u002B rand.NextDouble();\n}\n\nvar sigxyconst = plt.AddSignalXYConst(xs, ys);\nsigxyconst.StepDisplay = true;\nplt.SetAxisLimits(18700, 18730, -49.25, -46.75);\n\nplt.SaveFig(\u0022signalxyconst_step.png\u0022);"
    },
    {
      "id": "text_quickstart",
      "category": "Plottable: Text",
      "title": "Text",
      "description": "The Text plottable displays a string at an X/Y coordinate in unit space. Unlike the Annotation plottable, text moves when the axes are adjusted.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nint pointCount = 51;\ndouble[] x = DataGen.Consecutive(pointCount);\ndouble[] sin = DataGen.Sin(pointCount);\ndouble[] cos = DataGen.Cos(pointCount);\n\nplt.AddScatter(x, sin);\nplt.AddScatter(x, cos);\n\nplt.AddText(\u0022sample text\u0022, 10, .5, size: 16, color: Color.Blue);\n\nplt.SaveFig(\u0022text_quickstart.png\u0022);"
    },
    {
      "id": "text_alignment",
      "category": "Plottable: Text",
      "title": "Text Alignment and Rotation",
      "description": "Alignment indicates which corner is placed at the X/Y coordinate.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\nScottPlot.Alignment[] alignments = (ScottPlot.Alignment[])Enum.GetValues(typeof(ScottPlot.Alignment));\n\nfor (int i = 0; i \u003C alignments.Length; i\u002B\u002B)\n{\n    double frac = (double)i / alignments.Length;\n    double x = Math.Sin(frac * Math.PI * 2);\n    double y = Math.Cos(frac * Math.PI * 2);\n\n    var txt = plt.AddText(alignments[i].ToString(), x, y);\n    txt.Alignment = alignments[i];\n    txt.Font.Color = Color.Black; ;\n    txt.BackgroundColor = Color.LightSteelBlue;\n    txt.BackgroundFill = true;\n    txt.Rotation = 5;\n    txt.BorderSize = 2;\n    txt.BorderColor = Color.Navy;\n    txt.DragEnabled = true;\n\n    plt.AddPoint(x, y, Color.Red, 10);\n}\n\nplt.Margins(.5, .2);\n\nplt.SaveFig(\u0022text_alignment.png\u0022);"
    },
    {
      "id": "text_fonts",
      "category": "Plottable: Text",
      "title": "Custom Fonts",
      "description": "You can pass in a Font to further customize font options",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\n// display some interesting data in the background\nplt.AddSignal(DataGen.Sin(51), label: \u0022sin\u0022);\nplt.AddSignal(DataGen.Cos(51), label: \u0022cos\u0022);\n\n// add text with custom fonts\nplt.AddText(\u0022very graph\u0022, 25, .8, new Drawing.Font() { Name = \u0022comic sans ms\u0022, Size = 24, Color = Color.Blue, Bold = true });\nplt.AddText(\u0022so data\u0022, 0, 0, new Drawing.Font() { Name = \u0022comic sans ms\u0022, Size = 42, Color = Color.Magenta, Bold = true });\nplt.AddText(\u0022many documentation\u0022, 3, -.6, new Drawing.Font() { Name = \u0022comic sans ms\u0022, Size = 18, Color = Color.DarkBlue, Bold = true });\nplt.AddText(\u0022wow.\u0022, 10, .6, new Drawing.Font() { Name = \u0022comic sans ms\u0022, Size = 36, Color = Color.Green, Bold = true });\nplt.AddText(\u0022NuGet\u0022, 32, 0, new Drawing.Font() { Name = \u0022comic sans ms\u0022, Size = 24, Color = Color.Gold, Bold = true });\n\n// configure axis labels\nplt.YAxis.Label(label: \u0022vertical units\u0022, fontName: \u0022impact\u0022, size: 24, color: Color.Red, bold: true);\nplt.XAxis.Label(label: \u0022horizontal units\u0022, fontName: \u0022georgia\u0022, size: 24, color: Color.Blue, bold: true);\nplt.XAxis2.Label(label: \u0022Impressive Graph\u0022, size: 24, color: Color.Purple, bold: true);\n\n// configure tick labels\nplt.XAxis.TickLabelStyle(color: Color.DarkBlue, fontName: \u0022comic sans ms\u0022, fontSize: 16);\nplt.YAxis.TickLabelStyle(color: Color.DarkGreen, fontName: \u0022comic sans ms\u0022, fontSize: 16);\n\n// add a legend to the corner\nvar legend = plt.Legend();\nlegend.FontName = \u0022comic sans ms\u0022;\nlegend.FontSize = 18;\nlegend.FontBold = true;\nlegend.FontColor = Color.DarkBlue;\n\nplt.SaveFig(\u0022text_fonts.png\u0022);"
    },
    {
      "id": "tooltip_quickstart",
      "category": "Plottable: Tooltip",
      "title": "Tooltip Quickstart",
      "description": "Tooltips are annotations that point to an X/Y coordinate on the plot",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] ys = DataGen.Sin(50);\nplt.AddSignal(ys);\n\nplt.AddTooltip(label: \u0022Special Point\u0022, x: 17, y: ys[17]);\n\nplt.SaveFig(\u0022tooltip_quickstart.png\u0022);"
    },
    {
      "id": "tooltip_font",
      "category": "Plottable: Tooltip",
      "title": "Tooltip Font",
      "description": "Tooltips fonts can be customized",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] ys = DataGen.Sin(50);\nplt.AddSignal(ys);\n\nvar tt1 = plt.AddTooltip(\u0022Top\u0022, 12, ys[12]);\ntt1.Font.Color = System.Drawing.Color.Magenta;\ntt1.Font.Size = 24;\n\nvar tt2 = plt.AddTooltip(\u0022Negative Slope\u0022, 25, ys[25]);\ntt2.Font.Name = \u0022Comic Sans MS\u0022;\ntt2.Font.Bold = true;\n\nplt.SaveFig(\u0022tooltip_font.png\u0022);"
    },
    {
      "id": "tooltip_colors",
      "category": "Plottable: Tooltip",
      "title": "Tooltip Colors",
      "description": "Tooltips border and fill styles can be customized",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] ys = DataGen.Sin(50);\nplt.AddSignal(ys);\n\nvar tt = plt.AddTooltip(\u0022This point has\\na negative slope\u0022, 25, ys[25]);\ntt.Font.Size = 24;\ntt.Font.Color = System.Drawing.Color.White;\ntt.FillColor = System.Drawing.Color.Blue;\ntt.BorderWidth = 5;\ntt.BorderColor = System.Drawing.Color.Navy;\ntt.ArrowSize = 15;\n\nplt.SaveFig(\u0022tooltip_colors.png\u0022);"
    },
    {
      "id": "vectorField_quickstart",
      "category": "Plottable: Vector Field",
      "title": "Quickstart",
      "description": "A vector field can be useful to show data explained by differential equations",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] xPositions = DataGen.Range(0, 10);\ndouble[] yPositions = DataGen.Range(0, 10);\nVector2[,] vectors = new Vector2[xPositions.Length, yPositions.Length];\n\nfor (int x = 0; x \u003C xPositions.Length; x\u002B\u002B)\n    for (int y = 0; y \u003C yPositions.Length; y\u002B\u002B)\n        vectors[x, y] = new Vector2(\nx: Math.Sin(xPositions[x]),\ny: Math.Sin(yPositions[y]));\n\nplt.AddVectorField(vectors, xPositions, yPositions);\n\nplt.SaveFig(\u0022vectorField_quickstart.png\u0022);"
    },
    {
      "id": "vectorField_angleMag",
      "category": "Plottable: Vector Field",
      "title": "Angle and Magnitude",
      "description": "This example demonstrates how to define vectors according to a given angle and magnitude.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] xs = DataGen.Range(-5, 6);\ndouble[] ys = DataGen.Range(-5, 6);\nVector2[,] vectors = new Vector2[xs.Length, ys.Length];\n\nfor (int i = 0; i \u003C xs.Length; i\u002B\u002B)\n{\n    for (int j = 0; j \u003C ys.Length; j\u002B\u002B)\n    {\n        double slope = -xs[i];\n        double magnitude = Math.Abs(xs[i]);\n        double angle = Math.Atan(slope);\n\n        vectors[i, j] = new Vector2(Math.Cos(angle) * magnitude, Math.Sin(angle) * magnitude);\n    }\n}\n\nplt.AddVectorField(vectors, xs, ys);\n\nplt.SaveFig(\u0022vectorField_angleMag.png\u0022);"
    },
    {
      "id": "vectorField_colormap",
      "category": "Plottable: Vector Field",
      "title": "Custom Colormap",
      "description": "A colormap can be supplied to color arrows according to their magnitude",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] xs = DataGen.Range(-5, 5, .5);\ndouble[] ys = DataGen.Range(-5, 5, .5);\nVector2[,] vectors = new Vector2[xs.Length, ys.Length];\ndouble r = 0.5;\n\n\nfor (int i = 0; i \u003C xs.Length; i\u002B\u002B)\n{\n    for (int j = 0; j \u003C ys.Length; j\u002B\u002B)\n    {\n        double x = ys[j];\n        double y = -9.81 / r * Math.Sin(xs[i]);\n\n        vectors[i, j] = new Vector2(x, y);\n    }\n}\n\nplt.AddVectorField(vectors, xs, ys, colormap: Drawing.Colormap.Turbo);\nplt.XLabel(\u0022\u03B8\u0022);\nplt.YLabel(\u0022d\u03B8/dt\u0022);\n\nplt.SaveFig(\u0022vectorField_colormap.png\u0022);"
    },
    {
      "id": "vectorField_scaleFactor",
      "category": "Plottable: Vector Field",
      "title": "Custom Scale Factor",
      "description": "A custom scale factor can adjust the length of the arrows.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] xs = DataGen.Range(-1.5, 1.5, .25);\ndouble[] ys = DataGen.Range(-1.5, 1.5, .25);\nVector2[,] vectors = new Vector2[xs.Length, ys.Length];\n\nfor (int i = 0; i \u003C xs.Length; i\u002B\u002B)\n{\n    for (int j = 0; j \u003C ys.Length; j\u002B\u002B)\n    {\n        double x = xs[i];\n        double y = ys[j];\n        var e = Math.Exp(-x * x - y * y);\n        var dx = (1 - 2 * x * x) * e;\n        var dy = -2 * x * y * e;\n\n        vectors[i, j] = new Vector2(dx, dy);\n    }\n}\n\nplt.AddVectorField(vectors, xs, ys, scaleFactor: 0.3);\n\nplt.SaveFig(\u0022vectorField_scaleFactor.png\u0022);"
    },
    {
      "id": "vectorField_fancytips",
      "category": "Plottable: Vector Field",
      "title": "Scaled Arrowheads",
      "description": "Use a slower drawing method that draws tips that are proportional to the length of the arrows.",
      "code": "var plt = new ScottPlot.Plot(600, 400);\n\ndouble[] xPositions = DataGen.Range(0, 10);\ndouble[] yPositions = DataGen.Range(0, 10);\nVector2[,] vectors = new Vector2[xPositions.Length, yPositions.Length];\n\nfor (int x = 0; x \u003C xPositions.Length; x\u002B\u002B)\n    for (int y = 0; y \u003C yPositions.Length; y\u002B\u002B)\n        vectors[x, y] = new Vector2(\n  x: Math.Sin(xPositions[x]),\n  y: Math.Sin(yPositions[y]));\n\nvar vf = plt.AddVectorField(vectors, xPositions, yPositions);\nvf.ScaledArrowheads = true;\nvf.Anchor = ArrowAnchor.Base;\nvf.MarkerSize = 3;\n\nplt.SaveFig(\u0022vectorField_fancytips.png\u0022);"
    }
  ]
}